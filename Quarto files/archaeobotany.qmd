---
always_allow_html: true
---

# Archaeobotany {#sec-archaeobotany style="text-align:justify;"}

```{r}
#| echo: false
#| message: false
#| output: false

# Load functions
source('functions_bot.R')

# Libraries
library(rethinking)
library(tidybayes.rethinking)
library(tidybayes)
```

::: callout-important
## Page under construction {style="text-align:justify;"}

The results presented here are preliminary and the chapter has yet to be written.
:::

In this chapter, I will present the macrobotanical data from 190 case studies used to carry on this research (@sec-materials-bot), along with the statistics performed on the data. The results will be first presented temporally, and a discussion of the diachronic trends will follow at the end of the chapter.

## Case studies {style="text-align:justify;"}

The following map shows the sites under investigation, divided by chronology. Please select the desired chronology (or chronologies) from the legend at the top-right of the map.

```{r}
#| echo: false
#| output: false

# Load libraries
library(sp)
library(rgdal)
library(leaflet)
library(leaflet.extras)
library(htmltools)
library(tidyverse)
library(fontawesome) 

# Get an Italy shapefile
#download.file(url = 'http://biogeo.ucdavis.edu/data/diva/adm/ITA_adm.zip', 
            #  destfile = 'italy.zip')
#unzip(zipfile = 'italy.zip')

italy <- readOGR('Italy_SHP/ITA_Peninsula.shp')
bot_map <- read.csv("/Users/robertoragno/Desktop/University/Bari/PhD - Quarto/Database export/plants.csv", header=TRUE, sep=";")

# Grouping
bot_map_R <- filter(bot_map, Chronology=="R")
bot_map_LR<- filter(bot_map, Chronology=="LR")
bot_map_EMA<- filter(bot_map, Chronology=="EMA")
bot_map_Ma<- filter(bot_map, Chronology=="Ma")

#Icon for the map

Icon_red <- awesomeIcons(
  text = fa("wheat-awn"),
  iconColor = 'yellow',
  library = 'fa',
  markerColor = "red"
)

Icon_lightred <- awesomeIcons(
  text = fa("wheat-awn"),
  iconColor = 'yellow',
  library = 'glyphicon',
  markerColor = "lightred"
)

Icon_lightgray <- awesomeIcons(
  text = fa("wheat-awn"),
  iconColor = 'black',
  library = 'glyphicon',
  markerColor = "lightgray"
)

Icon_green <- awesomeIcons(
  text = fa("wheat-awn"),
  iconColor = 'darkgreen',
  library = 'glyphicon',
  markerColor = "lightgreen"
)

# Build the map
italy_bot_map <- leaflet(data=italy) %>%
  addProviderTiles(providers$CartoDB.Positron,  group = "Political") %>%
  addProviderTiles(providers$Esri.WorldPhysical, group = "Physical") %>%  addPolygons(weight = 1, 
              smoothFactor = 0.5,
              opacity = 0.2, 
              fillOpacity = 0.5,
              fillColor = "#F9F5EB",
              color="#D7A86E"
              ) %>%
  addAwesomeMarkers(data=bot_map_R, lng = bot_map_R$x, lat = bot_map_R$y,
                    group="R", 
                    icon = Icon_red,
                    popup = paste(
                      "<b>", bot_map_R$site_name, "</b>",
                      "<hr style='border:2px solid green; color: solid green, border-radius:2px; margin-top:1.5px; margin-bottom:5px'>",
                   "<b>Site ID:</b>", bot_map_R$site_code,"<br>",
                           "<b>Type:</b>", bot_map_R$type_name, "<br>",
                           "<b>Centuries:</b>", bot_map_R$data_valid_start,
                           "-", bot_map_R$data_valid_end, "<br>",
                           "<b>Chronology:</b>", bot_map_R$Chronology, "<br>",
                           "<b>Reference:</b><i>", bot_map_R$short_ref, "</i>"
                           ), 
             label=~htmlEscape(bot_map_R$site_name)
 ) %>%
    addAwesomeMarkers(data=bot_map_LR, lng = bot_map_LR$x, lat = bot_map_LR$y,
                    group="LR",
                    icon = Icon_lightred,
                    popup = paste(
                      "<b>", bot_map_LR$site_name, "</b>",
                      "<hr style='border:2px solid green; color: solid green, border-radius:2px; margin-top:1.5px; margin-bottom:5px'>",
                   "<b>Site ID:</b>", bot_map_LR$site_code,"<br>",
                           "<b>Type:</b>", bot_map_LR$type_name, "<br>",
                           "<b>Centuries:</b>", bot_map_LR$data_valid_start,
                           "-", bot_map_LR$data_valid_end, "<br>",
                           "<b>Chronology:</b>", bot_map_LR$Chronology, "<br>",
                           "<b>Reference:</b><i>", bot_map_LR$short_ref, "</i>"
                           ), 
             label=~htmlEscape(bot_map_LR$site_name)
 ) %>%
      addAwesomeMarkers(data=bot_map_EMA, lng = bot_map_EMA$x, lat = bot_map_EMA$y,
                    group="EMA",
                    icon = Icon_lightgray,
                    popup = paste(
                      "<b>", bot_map_EMA$site_name, "</b>",
                      "<hr style='border:2px solid green; color: solid green, border-radius:2px; margin-top:1.5px; margin-bottom:5px'>",
                   "<b>Site ID:</b>", bot_map_EMA$site_code,"<br>",
                           "<b>Type:</b>", bot_map_EMA$type_name, "<br>",
                           "<b>Centuries:</b>", bot_map_EMA$data_valid_start,
                           "-", bot_map_EMA$data_valid_end, "<br>",
                           "<b>Chronology:</b>", bot_map_EMA$Chronology, "<br>",
                           "<b>Reference:</b><i>", bot_map_EMA$short_ref, "</i>"
                           ), 
             label=~htmlEscape(bot_map_EMA$site_name)
 ) %>%
        addAwesomeMarkers(data=bot_map_Ma, lng = bot_map_Ma$x, lat = bot_map_Ma$y,
                    group="Ma",
                    icon = Icon_green,
                    popup = paste(
                      "<b>", bot_map_Ma$site_name, "</b>",
                      "<hr style='border:2px solid green; color: solid green, border-radius:2px; margin-top:1.5px; margin-bottom:5px'>",
                   "<b>Site ID:</b>", bot_map_Ma$site_code,"<br>",
                           "<b>Type:</b>", bot_map_Ma$type_name, "<br>",
                           "<b>Centuries:</b>", bot_map_Ma$data_valid_start,
                           "-", bot_map_Ma$data_valid_end, "<br>",
                           "<b>Chronology:</b>", bot_map_Ma$Chronology, "<br>",
                           "<b>Reference:</b><i>", bot_map_Ma$short_ref, "</i>"
                           ), 
             label=~htmlEscape(bot_map_Ma$site_name)
 ) %>%
  addLayersControl(
    overlayGroups = c("R", "LR", "EMA", "Ma"),
    baseGroups = c("Political", "Physical"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  hideGroup(c("LR", "EMA", "Ma")) %>%
  addResetMapButton() %>%
  addFullscreenControl() %>%
  htmlwidgets::onRender("
    function(el, x) {
      var myMap = this;
      myMap.on('baselayerchange',
        function (e) {
          myMap.minimap.changeLayer(L.tileLayer.provider(e.name));
        })
    }")

```

```{r}
#| echo: false
#| output: false
#| eval: false

# If I want a general map

map_pal2 <- leaflet::colorFactor(palette = c("R" = "#283618", 
                                           "LR" = "#3e9b1c", 
                                           "EMA" = "#bc4749",
                                           "Ma" = "goldenrod"
                                           ), 
                               domain = bot_map$Chronology)

italy_bot_map2 <- leaflet(data=italy) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(weight = 1, 
              smoothFactor = 0.5,
              opacity = 0.2, 
              fillOpacity = 0.5,
              fillColor = "#F9F5EB",
              color="#D7A86E"
              ) %>%
  addCircleMarkers(
    lng=bot_map$x, lat=bot_map$y,
    label = ~htmlEscape(bot_map$site_name),
    color=map_pal2(bot_map$Chronology),
    fillOpacity = 0.5,
    stroke = F,
    radius=4,
     popup = paste("ID:", bot_map$site_code, "<br>",
                           "<b>Site:</b>", bot_map$site_name, "<br>",
                           "Type:", bot_map$type_name, "<br>",
                           "Chronology (c.):", bot_map$startcentury,
                           "-", bot_map$endcentury, "<br>",
                           "Data:", bot_map$available_data, "<br>",
                           "ID BOT:", bot_map$bot, "<br>",
                           "ID ZOO:", bot_map$zoo, "<br>",
                           "ID POLL:", bot_map$poll
                           )
  ) %>% 
  addLegend(position = "bottomright",
            values = bot_map$Chronology, # data frame column for legend
            opacity = .7, # alpha of the legend
            pal = map_pal2, # palette declared earlier
            title = "Data") %>%
  addResetMapButton()
```

::: {.content-visible when-format="html"}
```{r}
#| echo: false
#| label: fig-archaeobot-map
#| fig-cap: "**Legend**: `R` = Roman, `LR` = Late Roman, `EMA` = Early Middle Ages, `Ma` = 11th c. onwards "

italy_bot_map

```
:::

## Ubiquity {style="text-align:justify;"}

::: callout-note
I need to justify in this section why I have used a frequentist approach. Using Jeffreys interval would be ideal, but the amount of plots needed to graphically show the results would simply be ridiculous. This decision will probably be justified by saying that these are simply exploratory introductory figures, and maybe I can plot some important taxa using Jeffreys interval.
:::

::: {.content-visible when-format="html"}
In @sec-methods, ubiquity has been described as the best solution to present the archaeobotanical remains from the Italian peninsula, given the numerous biases in the samples. The heatmap below (@fig-heatmap-ubiquity) provides a good overview of the temporal trends of presence of cereals, legumes, fruits and nuts in the entire area under examination.
:::

::: {.content-visible when-format="pdf"}
In @sec-methods, ubiquity has been described as the best solution to present the archaeobotanical remains from the Italian peninsula, given the numerous biases in the samples. The heatmap below (@fig-heatmap-ubiquity-for-PDF) provides a good overview of the temporal trends of presence of cereals, legumes, fruits and nuts in the entire area under examination.
:::

```{r}
#| echo: false

# SQL file name: view_archaeobot without the Chronology column
#plants_export <- read.csv("/Users/robertoragno/Desktop/Learn #R/PhdTests/PhdTests/DATA/Archaeobotany/PlantsExport14July.csv", header=TRUE, sep=";")
plants_export <- bot_map[-5]

# SQL file name: Archaeobot_Condensed
# Import the file: the function Ubiquity_macroreg_chrono() requires the condensed plant table exported from the database. For more info, look at the Custom functions section.
Archaeobot_Condensed <- read.csv("/Users/robertoragno/Desktop/University/Bari/PhD - Quarto/Database export/Archaeobot_Condensed.csv", header=TRUE, sep=";")

# SQL file name: Archaeobot_viz
# It is the condensed table from the database, but without totals/plant type
Df_Cond_Plants <- read.csv("/Users/robertoragno/Desktop/University/Bari/PhD - Quarto/Database export/Archaeobot_Viz.csv", header=TRUE, sep=";")

```

::: {.content-visible when-format="html"}
```{r}
#| code-fold: true
#| output: false
#| code-summary: "Show the code"
#| code-overflow: wrap

# Load the libraries
# Note: these libraries are used for the data visualizations in this page.
library(RColorBrewer)
library(reshape2)
library(ggplot2)
library(hrbrthemes)
library(plotly)
library(patchwork)

## UBIQUITY

## Creating a dataframe that contains the ubiquity of each century under examination. 
Ubiquity_table <- data.frame(
  "I BCE" = archaeobotany_tables(plants_export, -1)$Ubiquity_exp,  
  "I CE" = archaeobotany_tables(plants_export, 1)$Ubiquity_exp,
  "II CE" = archaeobotany_tables(plants_export, 2)$Ubiquity_exp,
  "III CE" = archaeobotany_tables(plants_export, 3)$Ubiquity_exp,
  "IV CE" = archaeobotany_tables(plants_export, 4)$Ubiquity_exp,
  "V CE" = archaeobotany_tables(plants_export, 5)$Ubiquity_exp,
  "VI CE" = archaeobotany_tables(plants_export, 6)$Ubiquity_exp,
  "VII CE" = archaeobotany_tables(plants_export, 7)$Ubiquity_exp,
  "VIII CE" = archaeobotany_tables(plants_export, 8)$Ubiquity_exp,
  "IX CE" = archaeobotany_tables(plants_export, 9)$Ubiquity_exp,
  "X CE" = archaeobotany_tables(plants_export, 10)$Ubiquity_exp,
  "XI CE" = archaeobotany_tables(plants_export, 11)$Ubiquity_exp
  )

# Transform the ubiquity table into a matrix
Ubiquity_mat <- as.matrix(Ubiquity_table) 

# Rename the centuries
colnames(Ubiquity_mat) <- c("1st c. BCE", "1st c. CE", "2nd c. CE",
                            "3rd c. CE", "4th c. CE", "5th c. CE",
                            "6th c. CE", "7th c. CE", "8th c. CE",
                            "9th c. CE", "10th c. CE", "11th c. CE") 

# The data has to be molten to use it with ggplot2
# (package: reshape2)
Ubiquity_melt <- melt(Ubiquity_mat)

# Let's now rename the columns 
colnames(Ubiquity_melt) <- c("Taxon", "Century", "Ubiquity")

# Add a column for the text tooltip
Ubiquity_melt <- Ubiquity_melt %>%
  mutate(text = paste0("Taxon: ", Taxon, "\n", "Century: ", Century, "\n", "Value: ",round(Ubiquity,2)))

# Create the heatmap with ggplot2
Ubiquity_HM <- ggplot(Ubiquity_melt, aes(Century, Taxon, fill=Ubiquity, text=text)) + 
  geom_tile(colour="white") +
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "right",
        axis.ticks = element_blank(), 
        axis.text.x = element_text(angle = 90, hjust = 0)
        ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Ubiquity",
    subtitle="Diachronical heatmap of recorded plant species"
  ) +
  scale_fill_gradient(low = "white", high = "black")

```

```{r}
#| echo: false
#| label: fig-heatmap-ubiquity
#| fig-cap: "Diachronical heatmap of recorded plant species" 
#| fig-width: 5
#| fig-height: 6

ggplotly(Ubiquity_HM, tooltip="text")
```
:::

::: {.content-visible when-format="pdf"}
```{r}
#| echo: false
#| label: fig-heatmap-ubiquity-for-PDF
#| fig-cap: "Diachronical heatmap of recorded plant species" 
#| fig-width: 5
#| fig-height: 6

Ubiquity_HM
```
:::

```{r}
#| echo: false
#| eval: false
#| message: false

# JEFFREY S INTERVAL 

#Make a copy of the dataframe
plants_pa <- plants_export
# Presence/Absence
library(vegan)
plants_pa[,c(14:52)] <- decostand(plants_export[,c(14:52)], method="pa")
plants_pa <- replace(plants_pa, is.na(plants_pa), 0)

# Periods
dataset.centuries = c(-1:11)
dataset.centuries = subset(dataset.centuries, dataset.centuries!=0)

# Create a list to store the tables
plant_tables <- list()

# Loop through each plant column in the original dataframe
for (plant_col in colnames(plants_pa)[14:52]) {

  # Create a new tibble for the current plant
  plant_table <- tibble(
    Century = dataset.centuries,
    Beta1 = NA_real_,
    Beta2 = NA_real_,
    Tot_Pres = NA_real_,
    Tot_Sites = NA_real_
  )

  # Loop through each century
  for (i in seq_along(dataset.centuries)) {
    century = dataset.centuries[i]
    tmp = filter(plants_pa, 
               data_valid_start <= century & data_valid_end >= century & 
               !is.na(data_valid_start) & !is.na(data_valid_end))
    
    
    # Count the number of presences for the current plant and century
    presences <- sum(tmp[[plant_col]])
    
    # Count the total number of rows for the current century
    total_rows <- nrow(tmp)
    
    # Calculate the beta1 and beta2 values for the current plant and century
    beta1 <- 0.5 + presences
    beta2 <- 0.5 + total_rows - presences
    Tot_Sites <- total_rows
    Tot_Pres <- presences
    
    # Add the beta1 and beta2 values to the plant table
    plant_table$Beta1[i] <- beta1
    plant_table$Beta2[i] <- beta2
    plant_table$Tot_Sites[i] <- Tot_Sites
    plant_table$Tot_Pres[i] <- Tot_Pres
  }
  
  # Add the plant table to the list
  plant_tables[[plant_col]] <- plant_table
  plant_tables[[plant_col]]$Century <- as.factor(plant_tables[[plant_col]]$Century)

}


# Adds Violin-plot for Posterior estimates of Binomial using conjugate Beta prior
# x ... x coordinate  of the violin plot
# w ... width of the violin
# beta1,beta2 ... parameters of the beta distribution
# col ... fill color
# hpd ... quantile percentage range for region to be color filled


addBetaDens  <- function(x,beta1,beta2,w,col,hpd=0.9,betaprior=0.5)
{
	xx  <- round(seq(0,1,length.out=1000),3)
	dens  <- dbeta(xx,beta1,beta2)
	dens999lo  <- round(qbeta(0.001,beta1,beta2),3)
	dens999hi  <- round(qbeta(0.999,beta1,beta2),3)
	denshpdlo  <- round(qbeta(1-hpd,beta1,beta2),3)
	denshpdhi  <- round(qbeta(hpd,beta1,beta2),3)

	d999i  <- which(xx>=dens999lo&xx<=dens999hi)
	dhpdi  <- which(xx>=denshpdlo&xx<=denshpdhi) 
	
	maxLeft = x-w
	maxRight= x+w
	leftVals.999 = (dens[d999i]/(max(dens[d999i]))) * (maxLeft - x) + x
	rightVals.999 = (dens[d999i]/(max(dens[d999i]))) * (maxRight - x) + x 
	leftVals.hpd = (dens[dhpdi]/(max(dens[dhpdi]))) * (maxLeft - x) + x
	rightVals.hpd = (dens[dhpdi]/(max(dens[dhpdi]))) * (maxRight - x) + x 
	polygon(c(leftVals.999,rev(rightVals.999)),c(xx[d999i],rev(xx[d999i])),col=NULL,border = 'lightgrey')
	polygon(c(leftVals.hpd,rev(rightVals.hpd)),c(xx[dhpdi],rev(xx[dhpdi])),col=col,border=col)
	lines(c(maxLeft,maxRight),rep((beta1-betaprior)/(beta1+beta2-betaprior*2),2),lwd=2,col=1)
}

colors = gray(seq(0.7, 0.15, length.out = 20))

```

```{r}
#| echo: false
#| eval: false


# Get lower and upper confidence interval
library("ratesci")

test <- jeffreysci(
  x=plant_tables[["Vitis.vinifera"]]$Tot_Pres,
  n=plant_tables[["Vitis.vinifera"]]$Tot_Sites,
  level=0.90
  )

test_dist <- data.frame(
  Distribution = rbeta(1000, 
                   shape1=plant_tables[["Vitis.vinifera"]]$Beta1[1],
                   shape2=plant_tables[["Vitis.vinifera"]]$Beta2[1]
                     ),
  Century=plant_tables[["Vitis.vinifera"]]$Century[1]
  )

# Create an empty data frame to store the results
all_dists <- data.frame()

# Loop through all centuries (from 1 to 12)
for (i in 1:12) {
  # Generate the data for the current century using rbeta
  dist <- data.frame(
    Distribution = rbeta(1000,
shape1=plant_tables[["Vitis.vinifera"]]$Beta1[i],
shape2=plant_tables[["Vitis.vinifera"]]$Beta2[i]),
Century=plant_tables[["Vitis.vinifera"]]$Century[i]
  )
  
  # Add the data to the all_dists data frame
  all_dists <- rbind(all_dists, dist)
}

ggplot(all_dists, aes(x=Century, y=Distribution))+
  geom_boxplot(
    lower=test[,1], 
    upper=test[,2],
    middle=test[,3],
    alpha=.8,
    width=.5,
    outlier.colour = "red4",
    outlier.size=0.9,
    outlier.alpha=0.4
    )+ 
    geom_hline(
    yintercept = mean(all_dists$Distribution),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4")+
    labs(
    x = "Century",
    y = "Ubiquity",
    title = "Vitis Vinifera",
    caption = "90% Jeffreys interval boxplots where the middle line is the true estimate."
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  )

  

```

```{r}
#| eval: false
#| echo: false
# TEST AUTOMATION

# Define the column names
plant_tables.col_names <- names(plant_tables)

# Create an empty data frame to store the results
all_dists <- data.frame()

# Loop through all columns
for (col_name in plant_tables.col_names) {
  # Calculate the 90% Jeffreys interval for the column
  test <- jeffreysci(
    x = plant_tables[[col_name]]$Tot_Pres,
    n = plant_tables[[col_name]]$Tot_Sites,
    level = 0.90
  )
  
  # Loop through all centuries (from 1 to 12)
  for (i in 1:12) {
    # Generate the data for the current century using rbeta
    dist <- data.frame(
      Distribution = rbeta(1000,
        shape1 = plant_tables[[col_name]]$Beta1[i],
        shape2 = plant_tables[[col_name]]$Beta2[i]),
      Century = plant_tables[[col_name]]$Century[i]
    )
  
    # Add the data to the all_dists data frame
    all_dists <- rbind(all_dists, dist)
  }
  
  # Create a boxplot with the calculated Jeffreys interval
  ggplot(all_dists, aes(x = Century, y = Distribution)) +
    geom_boxplot(
      lower = test[, 1], 
      upper = test[, 2],
      middle = test[, 3],
      alpha = 0.8,
      width = 0.5,
      outlier.colour = "red4",
      outlier.size = 0.9
    ) + 
    geom_hline(
      yintercept = mean(all_dists$Distribution),
      linetype = "twodash",
      linewidth = 0.45,
      color = "red4"
    ) +
    labs(
      x = "Century",
      y = "Ubiquity",
      title = col_name,
      caption = "90% Jeffreys interval boxplots where the middle line is the true estimate."
    ) +
    theme_tidybayes() +
    theme(
      legend.position = "bottom",
      strip.background = element_rect(
        fill = "grey",
        linewidth = 0.1,
        colour = "black"
      ),
      panel.background = element_rect(fill = "grey90"),
      panel.border = element_rect(fill = NA, linewidth = 0.1),
      panel.grid.major.x = element_line(
        color = "grey50",
        linewidth = 0.25,
        linetype = 2
      ),
      axis.title.x.top = element_blank()
    )
  
  # Clear the all_dists data frame for the next column
  all_dists <- data.frame()
}

```

```{r}
#| echo: false
#| eval: false
#| label: fig-ubiquity-triticum-aest-jeffrey-int
#| fig-cap: "Posterior probability distribution of samples with cereal remains. The observed ubiquity is represented by the horizontal bar, while the highlighted areas represent the 90% Jeffreys interval."
#| fig-subcap: 
#|  - "Triticum aestivum/durum"
#|  - "Hordeum vulgare"
#|  - "Triticum monococcum"
#|  - "Triticum dicoccum"
#|  - "Panicum milliaceum"
#|  - "Setaria italica"
#|  - "Secale cereale"
#|  - "Sorghum bicolor"
#| layout-ncol: 2
#| layout-nrow: 4
#| fig-height: 4

# 1. T. aest. durum.
par(mar=c(3,4,5,1))
plot(NULL,xlim=c(0,12), ylim=c(0,1),xlab='',ylab='Proportion Sites',axes=FALSE, main='Triticum aestivum / durum')

for (i in seq_along(dataset.centuries)) {
	addBetaDens(x=i,
	            beta1=plant_tables[["Triticum.aestivum.durum"]]$Beta1[i],
	            beta2=plant_tables[["Triticum.aestivum.durum"]]$Beta2[i],
	            w=0.3, 
	            col=colors[i])
}

axis(side=1,at=c(1:12),
     labels=dataset.centuries,
     tick=FALSE,
     cex=1.2)
abline(v = c(1:12 +0.5),lty=2)
axis(side=2,at=seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)
axis(side=2,at=1.1+seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)


# 2. Hordeum
par(mar=c(3,4,5,1))
plot(NULL,xlim=c(0,12), ylim=c(0,1),xlab='',ylab='Proportion Sites',axes=FALSE, main='Hordeum v.')

for (i in seq_along(dataset.centuries)) {
  addBetaDens(x=i,
              beta1=plant_tables[["Hordeum.vulgare"]]$Beta1[i],
              beta2=plant_tables[["Hordeum.vulgare"]]$Beta2[i],
              w=0.3, 
              col=colors[i])
}

axis(side=1,at=c(1:12),
     labels=dataset.centuries,
     tick=FALSE,
     cex=1.2)
abline(v = c(1:12 +0.5),lty=2)
axis(side=2,at=seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)
axis(side=2,at=1.1+seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)


# 3. Monococcum
par(mar=c(3,4,5,1))
plot(NULL,xlim=c(0,12), ylim=c(0,1),xlab='',ylab='Proportion Sites',axes=FALSE, main='Triticum monococcum')

for (i in seq_along(dataset.centuries)) {
  addBetaDens(x=i,
              beta1=plant_tables[["Triticum.monococcum"]]$Beta1[i],
              beta2=plant_tables[["Triticum.monococcum"]]$Beta2[i],
              w=0.3, 
              col=colors[i])
}

axis(side=1,at=c(1:12),
     labels=dataset.centuries,
     tick=FALSE,
     cex=1.2)
abline(v = c(1:12 +0.5),lty=2)
axis(side=2,at=seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)
axis(side=2,at=1.1+seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)

# 4. dicoccum
par(mar=c(3,4,5,1))
plot(NULL,xlim=c(0,12), ylim=c(0,1),xlab='',ylab='Proportion Sites',axes=FALSE, main='Triticum dicoccum')

for (i in seq_along(dataset.centuries)) {
  addBetaDens(x=i,
              beta1=plant_tables[["Triticum.dicoccum"]]$Beta1[i],
              beta2=plant_tables[["Triticum.dicoccum"]]$Beta2[i],
              w=0.3, 
              col=colors[i])
}

axis(side=1,at=c(1:12),
     labels=dataset.centuries,
     tick=FALSE,
     cex=1.2)
abline(v = c(1:12 +0.5),lty=2)
axis(side=2,at=seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)
axis(side=2,at=1.1+seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)

# 5. Panicum m.
par(mar=c(3,4,5,1))
plot(NULL,xlim=c(0,12), ylim=c(0,1),xlab='',ylab='Proportion Sites',axes=FALSE, main='Panicum milliaceum')

for (i in seq_along(dataset.centuries)) {
  addBetaDens(x=i,
              beta1=plant_tables[["Panicum.milliaceum"]]$Beta1[i],
              beta2=plant_tables[["Panicum.milliaceum"]]$Beta2[i],
              w=0.3, 
              col=colors[i])
}

axis(side=1,at=c(1:12),
     labels=dataset.centuries,
     tick=FALSE,
     cex=1.2)
abline(v = c(1:12 +0.5),lty=2)
axis(side=2,at=seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)
axis(side=2,at=1.1+seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)

# 6. Setaria italica
par(mar=c(3,4,5,1))
plot(NULL,xlim=c(0,12), ylim=c(0,1),xlab='',ylab='Proportion Sites',axes=FALSE, 
     main='Setaria italica')

for (i in seq_along(dataset.centuries)) {
  addBetaDens(x=i,
              beta1=plant_tables[["Setaria.italica"]]$Beta1[i],
              beta2=plant_tables[["Setaria.italica"]]$Beta2[i],
              w=0.3, 
              col=colors[i])
}

axis(side=1,at=c(1:12),
     labels=dataset.centuries,
     tick=FALSE,
     cex=1.2)
abline(v = c(1:12 +0.5),lty=2)
axis(side=2,at=seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)
axis(side=2,at=1.1+seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)

# 7. Rye
par(mar=c(3,4,5,1))
plot(NULL,xlim=c(0,12), ylim=c(0,1),xlab='',ylab='Proportion Sites',axes=FALSE, 
     main='Secale cereale')

for (i in seq_along(dataset.centuries)) {
  addBetaDens(x=i,
              beta1=plant_tables[["Secale.cereale"]]$Beta1[i],
              beta2=plant_tables[["Secale.cereale"]]$Beta2[i],
              w=0.3, 
              col=colors[i])
}

axis(side=1,at=c(1:12),
     labels=dataset.centuries,
     tick=FALSE,
     cex=1.2)
abline(v = c(1:12 +0.5),lty=2)
axis(side=2,at=seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)
axis(side=2,at=1.1+seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)

# 8. Sorghum
par(mar=c(3,4,5,1))
plot(NULL,xlim=c(0,12), ylim=c(0,1),xlab='',ylab='Proportion Sites',axes=FALSE, 
     main='Sorghum bicolor')

for (i in seq_along(dataset.centuries)) {
  addBetaDens(x=i,
              beta1=plant_tables[["Sorghum.bicolor"]]$Beta1[i],
              beta2=plant_tables[["Sorghum.bicolor"]]$Beta2[i],
              w=0.3, 
              col=colors[i])
}

axis(side=1,at=c(1:12),
     labels=dataset.centuries,
     tick=FALSE,
     cex=1.2)
abline(v = c(1:12 +0.5),lty=2)
axis(side=2,at=seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)
axis(side=2,at=1.1+seq(0,1,length.out=5),labels=seq(0,1,length.out = 5),las=2)

```

```{r}
#| echo: false
#| eval: false

# MACROREGION
#Make a copy of the dataframe
plants_pa_mr <- Df_Cond_Plants

# Presence/Absence
plants_pa_mr[,c(11:50)] <- decostand(plants_pa_mr[,c(11:50)], method="pa")
plants_pa_mr <- replace(plants_pa_mr, is.na(plants_pa_mr), 0)

# Macroregions
dataset.macroregions = c("Southern Italy", "Central Italy", "Northern Italy")

# Chronologies
plants_pa_mr.R = subset(plants_pa_mr, Chronology=="R")
plants_pa_mr.LR = subset(plants_pa_mr, Chronology=="LR")
plants_pa_mr.EMA = subset(plants_pa_mr, Chronology=="EMA")
plants_pa_mr.Ma = subset(plants_pa_mr, Chronology=="Ma")

# Create a list to store the tables
plant_tables_mr.R <- list()

# Loop through each plant column in the original dataframe
for (plant_col in colnames(plants_pa_mr.R)[11:50]) {

  # Create a new tibble for the current plant
  plant_table_mr.R <- tibble(
    Macroregion = dataset.macroregions,
    Beta1 = NA_real_,
    Beta2 = NA_real_,
    Tot_Pres = NA_real_,
    Tot_Sites = NA_real_
  )

  # Loop through each century
  for (i in seq_along(dataset.macroregions)) {
    macroregion = dataset.macroregions[i]
    tmp = filter(plants_pa_mr.R, name_macroreg==macroregion)
    
    # Count the number of presences for the current plant and century
    presences <- sum(tmp[[plant_col]])
    
    # Count the total number of rows for the current century
    total_rows <- nrow(tmp)
    
    # Calculate the beta1 and beta2 values for the current plant and macroregion
    beta1 <- 0.5 + presences
    beta2 <- 0.5 + total_rows - presences
    Tot_Sites <- total_rows
    Tot_Pres <- presences
    
    # Add the beta1 and beta2 values to the plant table
    plant_table_mr.R$Beta1[i] <- beta1
    plant_table_mr.R$Beta2[i] <- beta2
    plant_table_mr.R$Tot_Sites[i] <- Tot_Sites
    plant_table_mr.R$Tot_Pres[i] <- Tot_Pres
  }
  
  # Add the plant table to the list
  plant_tables_mr.R[[plant_col]] <- plant_table_mr.R
  plant_tables_mr.R[[plant_col]]$Macroregion <- as.factor(plant_tables_mr.R[[plant_col]]$Macroregion)

}

# Get lower and upper confidence interval

test <- jeffreysci(
  x=plant_tables_mr.R[["Grape"]]$Tot_Pres,
  n=plant_tables_mr.R[["Grape"]]$Tot_Sites,
  level=0.90
  )

# Create an empty data frame to store the results
all_dists <- data.frame()

# Loop through all centuries (from 1 to 12)
for (i in 1:3) {
  # Generate the data for the current century using rbeta
  dist <- data.frame(
    Distribution = rbeta(1000,
shape1=plant_tables_mr.R[["Grape"]]$Beta1[i],
shape2=plant_tables_mr.R[["Grape"]]$Beta2[i]),
Macroregion=plant_tables_mr.R[["Grape"]]$Macroregion[i]
  )
  
  # Add the data to the all_dists data frame
  all_dists <- rbind(all_dists, dist)
}

ggplot(all_dists, aes(x=Macroregion, y=Distribution))+
  geom_boxplot(
    lower=test[,1], 
    upper=test[,2],
    middle=test[,3],
    alpha=.8,
    width=.5,
    outlier.colour = "red4",
    outlier.size=0.9,
    outlier.alpha=0.4
    )+ 
    geom_hline(
    yintercept = mean(all_dists$Distribution),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4")+
    labs(
    x = "Macroregion",
    y = "Ubiquity",
    title = "Vitis Vinifera",
    caption = "90% Jeffreys interval boxplots where the middle line is the true estimate."
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  )

  


```

### Ubiquity by macroregion {#sec-macroregional-differences-ubiquity}

::: callout-alert
Probably delete, in favor of the bayesian predictions. If this section is kept, make sure to explain that ubiquity was calculated by macroregion only because it was more reliable etc etc
:::

::: {.content-visible when-format="html"}
The heatmap (@fig-heatmap-ubiquity) shows the diachronical ubiquity values of the Italian mainland. It is possible however to compare plants' ubiquity values in different areas of the peninsula. The R function `Ubiquity_macroreg_chrono()` (@sec-Ubiquity-macroreg-chrono) was created to subset data from Northern, Central and Southern Italian regions, using modern boundaries. Archaeobotanical data from Italy is scarce, and subsetting the dataset required a larger chronological division to have enough sites for a valid statistical interpretation of the results. For this reason, the ubiquity values are presented using the variable `Chronology` rather than subsetting the individual centuries. For a clearer reading of the plot, the taxa have been divided into--Cereals, Pulses and Fruits/Nuts. Some taxa have been omitted from the plot.
:::

::: {.content-visible when-format="pdf"}
The heatmap (@fig-heatmap-ubiquity-for-PDF) shows the diachronical ubiquity values of the Italian mainland. It is possible however to compare plants' ubiquity values in different areas of the peninsula. The R function `Ubiquity_macroreg_chrono()` (@sec-custom-functions) was created to subset data from Northern, Central and Southern Italian regions, using modern boundaries. Archaeobotanical data from Italy is scarce, and subsetting the dataset required a larger chronological division to have enough sites for a valid statistical interpretation of the results. For this reason, the ubiquity values are presented using the variable `Chronology` rather than subsetting the individual centuries. For a clearer reading of the plot, the taxa have been divided into--Cereals, Pulses and Fruits/Nuts. Some taxa have been omitted from the plot.
:::

::: {.content-visible when-format="html"}
```{r}
#| echo: false
#| output: false
#| code-summary: "Show the code: data preparation"
#| code-overflow: wrap

# Ubiquity by Italian Macro regions: Northern, Central and Southern Italy

# Load the libraries
library(vegan)
library(matrixStats)
library(patchwork)

# Creating a dataframe with the ubiquities of all macroregions and chronologies
bot_macroreg <- rbind(
  Ubiquity_R_NI <- Ubiquity_macroreg_chrono(Archaeobot_Condensed,"Northern Italy", "R"),
  Ubiquity_R_CI <- Ubiquity_macroreg_chrono(Archaeobot_Condensed,"Central Italy", "R"),
  Ubiquity_R_SI <- Ubiquity_macroreg_chrono(Archaeobot_Condensed,"Southern Italy", "R"),
  Ubiquity_LR_NI <- Ubiquity_macroreg_chrono(Archaeobot_Condensed,"Northern Italy", "LR"),
  Ubiquity_LR_CI <- Ubiquity_macroreg_chrono(Archaeobot_Condensed,"Central Italy", "LR"),
  Ubiquity_LR_SI <- Ubiquity_macroreg_chrono(Archaeobot_Condensed,"Southern Italy", "LR"),
  Ubiquity_EMA_NI <- Ubiquity_macroreg_chrono(Archaeobot_Condensed,"Northern Italy", "EMA"),
  Ubiquity_EMA_CI <- Ubiquity_macroreg_chrono(Archaeobot_Condensed,"Central Italy", "EMA"),
  Ubiquity_EMA_SI <- Ubiquity_macroreg_chrono(Archaeobot_Condensed,"Southern Italy", "EMA"),
  Ubiquity_Ma_NI <- Ubiquity_macroreg_chrono(Archaeobot_Condensed,"Northern Italy", "Ma"),
  Ubiquity_Ma_CI <- Ubiquity_macroreg_chrono(Archaeobot_Condensed,"Central Italy", "Ma"),
  Ubiquity_Ma_SI <- Ubiquity_macroreg_chrono(Archaeobot_Condensed,"Southern Italy", "Ma")
)

# Re-arranging the cereals/macroregions for visualisation on the Y axis
level_macroreg_order <- c("Southern Italy", "Central Italy", "Northern Italy")

level_cereals_order <- c("Common.Wheat", "Barley", "Rye", 
                         "Einkorn", "Emmer", "Proso.millet", 
                         "Foxtail.millet", "Oats", "Sorghum")

# Cereals
cer_ubiquity_macroreg.R <- filter(bot_macroreg, Chronology=="R" & Plant.Type=="Cereals")
cer_ubiquity_macroreg.R <- filter(cer_ubiquity_macroreg.R, Macroregion!="Central Italy")
cer_ubiquity_macroreg.LR <- filter(bot_macroreg, Chronology=="LR" & Plant.Type=="Cereals")
cer_ubiquity_macroreg.EMA <- filter(bot_macroreg, Chronology=="EMA" & Plant.Type=="Cereals")
cer_ubiquity_macroreg.Ma <- filter(bot_macroreg, (Chronology=="Ma" & Plant.Type=="Cereals"))
cer_ubiquity_macroreg.Ma <- filter(cer_ubiquity_macroreg.Ma, Macroregion!="Southern Italy")

#Pulses
puls_ubiquity_macroreg.R <- filter(bot_macroreg, Chronology=="R" & Plant.Type=="Pulses")
puls_ubiquity_macroreg.R <- filter(puls_ubiquity_macroreg.R, Macroregion!="Central Italy")
puls_ubiquity_macroreg.R <- filter(puls_ubiquity_macroreg.R, Plant!="Chickpea")
puls_ubiquity_macroreg.LR <- filter(bot_macroreg, Chronology=="LR" & Plant.Type=="Pulses")
puls_ubiquity_macroreg.LR <- filter(puls_ubiquity_macroreg.LR, 
                                    Macroregion!="Southern Italy")
puls_ubiquity_macroreg.LR <- filter(puls_ubiquity_macroreg.LR, Plant!="Chickpea")
puls_ubiquity_macroreg.EMA <- filter(bot_macroreg, Chronology=="EMA" & Plant.Type=="Pulses")
puls_ubiquity_macroreg.Ma <- filter(bot_macroreg, Chronology=="Ma"  & Plant.Type=="Pulses")
puls_ubiquity_macroreg.Ma <- filter(puls_ubiquity_macroreg.Ma, 
                                    Macroregion!="Southern Italy")

#Fruits (+ Subset)
fnuts_ubiquity_macroreg.R <- filter(bot_macroreg, Chronology=="R" & Plant.Type=="Fruits/Nuts")
fnuts_ubiquity_macroreg.R <- subset(fnuts_ubiquity_macroreg.R, (Plant == "Wild.Cherry" | Plant == "Walnut" | Plant == "Peach" | Plant == "Olive" |Plant == "Grape" | Plant =="Fig" | Plant =="Apple"))
fnuts_ubiquity_macroreg.R <- filter(fnuts_ubiquity_macroreg.R, Macroregion!="Central Italy")
fnuts_ubiquity_macroreg.LR <- filter(bot_macroreg, Chronology=="LR" & Plant.Type=="Fruits/Nuts")
fnuts_ubiquity_macroreg.LR <- subset(fnuts_ubiquity_macroreg.LR, (Plant == "Wild.Cherry" | Plant == "Walnut" | Plant == "Peach" | Plant == "Olive" |Plant == "Grape" | Plant =="Fig" | Plant =="Apple"))
fnuts_ubiquity_macroreg.EMA <- filter(bot_macroreg, Chronology=="EMA" & Plant.Type=="Fruits/Nuts")
fnuts_ubiquity_macroreg.EMA <- subset(fnuts_ubiquity_macroreg.EMA, (Plant == "Wild.Cherry" | Plant == "Walnut" | Plant == "Peach" | Plant == "Olive" |Plant == "Grape" | Plant =="Fig" | Plant =="Apple"))
fnuts_ubiquity_macroreg.Ma <- filter(bot_macroreg, Chronology=="Ma"  & Plant.Type=="Fruits/Nuts")
fnuts_ubiquity_macroreg.Ma <- subset(fnuts_ubiquity_macroreg.Ma, (Plant == "Wild.Cherry" | Plant == "Walnut" | Plant == "Peach" | Plant == "Olive" |Plant == "Grape" | Plant =="Fig" | Plant =="Apple"))
fnuts_ubiquity_macroreg.Ma <- filter(fnuts_ubiquity_macroreg.Ma, Macroregion!="Southern Italy")

```

```{r}
#| echo: false
#| output: false
#| code-summary: "Show the code: plots"
#| code-overflow: wrap

# Cereals plots ubiquity
cer_ubiquity_macroreg_R.HM <- ggplot(cer_ubiquity_macroreg.R, aes(
  factor(Macroregion, levels=(level_macroreg_order)),
  factor(Plant, levels=rev(level_cereals_order)),
  fill=(Ubiquity)
)) + 
  geom_tile(colour="white") +
  geom_text(aes(label = Ubiquity), colour="white", size=3)+ 
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "none",
        axis.ticks = element_blank()
  ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Roman"
  ) +  scale_fill_gradient(low = "white", high = "black")


cer_ubiquity_macroreg_LR.HM <- ggplot(cer_ubiquity_macroreg.LR, aes(
  factor(Macroregion, levels=(level_macroreg_order)),
  factor(Plant, levels=rev(level_cereals_order)),
  fill=(Ubiquity)
)) + 
  geom_tile(colour="white") +
  geom_text(aes(label = Ubiquity), colour="white", size=3)+ 
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "none",
        axis.ticks = element_blank()
  ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Late Roman"
  ) +  scale_fill_gradient(low = "white", high = "black")

cer_ubiquity_macroreg_EMA.HM <- ggplot(cer_ubiquity_macroreg.EMA, aes(
  factor(Macroregion, levels=(level_macroreg_order)),
  factor(Plant, levels=rev(level_cereals_order)),
  fill=(Ubiquity)
)) + 
  geom_tile(colour="white") +
  geom_text(aes(label = Ubiquity), colour="white", size=3)+ 
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "none",
        axis.ticks = element_blank()
  ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Early Medieval"
  ) +  scale_fill_gradient(low = "white", high = "black")

cer_ubiquity_macroreg_Ma.HM <- ggplot(cer_ubiquity_macroreg.Ma, aes(
  factor(Macroregion, levels=(level_macroreg_order)),
  factor(Plant, levels=rev(level_cereals_order)),
  fill=(Ubiquity)
)) + 
  geom_tile(colour="white") +
  geom_text(aes(label = Ubiquity), colour="white", size=3)+ 
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "none",
        axis.ticks = element_blank()
  ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Medieval"
  ) +  scale_fill_gradient(low = "white", high = "black")


Cereals_Ubiquity_MacroReg_Patchwork <- (cer_ubiquity_macroreg_R.HM|cer_ubiquity_macroreg_LR.HM)/(cer_ubiquity_macroreg_EMA.HM|cer_ubiquity_macroreg_Ma.HM)
Cereals_Ubiquity_MacroReg_Patchwork + plot_annotation(
  title = 'Cereals',
  subtitle = 'Ubiquity (%), plotted by macroregion and chronology.',
  caption='Note: Data was too scarce for Roman Central Italy and Medieval Southern Italy.'
  )


# Pulses plots ubiquity
puls_ubiquity_macroreg_R.HM <- ggplot(puls_ubiquity_macroreg.R, aes(
  factor(Macroregion, levels=(level_macroreg_order)),
  Plant,
  fill=(Ubiquity)
)) + 
  geom_tile(colour="white") +
  geom_text(aes(label = Ubiquity), colour="#cfcfcf", size=3)+ 
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "none",
        axis.ticks = element_blank()
  ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Roman"
  ) +  scale_fill_gradient(low = "white", high = "black")


puls_ubiquity_macroreg_LR.HM <- ggplot(puls_ubiquity_macroreg.LR, aes(
  factor(Macroregion, levels=(level_macroreg_order)),
  Plant,
  fill=(Ubiquity)
)) + 
  geom_tile(colour="white") +
  geom_text(aes(label = Ubiquity), colour="#ffffff", size=3)+ 
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "none",
        axis.ticks = element_blank()
  ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Late Roman"
  ) +  scale_fill_gradient(low = "white", high = "black")

puls_ubiquity_macroreg_EMA.HM <- ggplot(puls_ubiquity_macroreg.EMA, aes(
  factor(Macroregion, levels=(level_macroreg_order)),
  Plant,
  fill=(Ubiquity)
)) + 
  geom_tile(colour="white") +
  geom_text(aes(label = Ubiquity), colour="white", size=3)+ 
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "none",
        axis.ticks = element_blank()
  ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Early Medieval"
  ) +  scale_fill_gradient(low = "white", high = "black")

puls_ubiquity_macroreg_Ma.HM <- ggplot(puls_ubiquity_macroreg.Ma, aes(
  factor(Macroregion, levels=(level_macroreg_order)),
  Plant,
  fill=(Ubiquity)
)) + 
  geom_tile(colour="white") +
  geom_text(aes(label = Ubiquity), colour="white", size=3)+ 
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "none",
        axis.ticks = element_blank()
  ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Medieval"
  ) +  scale_fill_gradient(low = "white", high = "black")


Pulses_Ubiquity_MacroReg_Patchwork <- (puls_ubiquity_macroreg_R.HM|puls_ubiquity_macroreg_LR.HM)/(puls_ubiquity_macroreg_EMA.HM|puls_ubiquity_macroreg_Ma.HM)
Pulses_Ubiquity_MacroReg_Patchwork + plot_annotation(
  title = 'Pulses',
  subtitle = 'Ubiquity (%), plotted by macroregion and chronology.',
  caption='Note: Data was too scarce for Roman Central Italy and Late Roman/Medieval Southern Italy.'
)

# Fruits nuts plots

fnuts_ubiquity_macroreg_R.HM <- ggplot(fnuts_ubiquity_macroreg.R, aes(
  factor(Macroregion, levels=(level_macroreg_order)),
  Plant,
  fill=(Ubiquity)
)) + 
  geom_tile(colour="white") +
  geom_text(aes(label = Ubiquity), colour="white", size=3)+ 
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "none",
        axis.ticks = element_blank()
  ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Roman"
  ) +  scale_fill_gradient(low = "white", high = "black")


fnuts_ubiquity_macroreg_LR.HM <- ggplot(fnuts_ubiquity_macroreg.LR, aes(
  factor(Macroregion, levels=(level_macroreg_order)),
  Plant,
  fill=(Ubiquity)
)) + 
  geom_tile(colour="white") +
  geom_text(aes(label = Ubiquity), colour="white", size=3)+ 
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "none",
        axis.ticks = element_blank()
  ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Late Roman"
  ) +  scale_fill_gradient(low = "white", high = "black")

fnuts_ubiquity_macroreg_EMA.HM <- ggplot(fnuts_ubiquity_macroreg.EMA, aes(
  factor(Macroregion, levels=(level_macroreg_order)),
  Plant,
  fill=(Ubiquity)
)) + 
  geom_tile(colour="white") +
  geom_text(aes(label = Ubiquity), colour="white", size=3)+ 
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "none",
        axis.ticks = element_blank()
  ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Early Medieval"
  ) +  scale_fill_gradient(low = "white", high = "black")

fnuts_ubiquity_macroreg_Ma.HM <- ggplot(fnuts_ubiquity_macroreg.Ma, aes(
  factor(Macroregion, levels=(level_macroreg_order)),
  Plant,
  fill=(Ubiquity)
)) + 
  geom_tile(colour="white") +
  geom_text(aes(label = Ubiquity), colour="white", size=3)+ 
  scale_alpha(range=c(0,1)) +
  scale_x_discrete("", expand = c(0, 0)) + 
  scale_y_discrete("", expand = c(0, 0)) + 
  theme_grey(base_size = 9) + 
  theme(legend.position = "none",
        axis.ticks = element_blank()
  ) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
  labs(
    title="Medieval"
  ) +  scale_fill_gradient(low = "white", high = "black")


FrNuts_Ubiquity_MacroReg_Patchwork <- (fnuts_ubiquity_macroreg_R.HM|fnuts_ubiquity_macroreg_LR.HM)/(fnuts_ubiquity_macroreg_EMA.HM|fnuts_ubiquity_macroreg_Ma.HM)
FrNuts_Ubiquity_MacroReg_Patchwork + plot_annotation(
  title = 'Fruits/Nuts',
  subtitle = 'Ubiquity (%), plotted by macroregion and chronology.',
  caption='Note: Data was too scarce for Roman Central Italy and Medieval Southern Italy.'
)


```
:::

#### Cereals

It is interesting to notice how in the **Roman age**, cereals are similarly ubiquitous in Southern and Northern Italy, although there are some exceptions (*i.e.* einkorn, rye, oats, and proso millet) that can derive from the randomness of sampling. Unfortunately, only three sites provided botanical samples for Roman Central Italy and their values have then been omitted from the plot. These sites (all from Tuscany) were studied by the Roman Peasant Project [@bowesRomanPeasantProject2020a] and only reported three kinds of cereal: common wheat, emmer, and barley. Similar ubiquity values from Northern and Southern Italy in the Roman age may suggest similar production patterns in the whole Italian mainland, even though more data is required. In the **Late Roman age**, ubiquity data has been calculated for the three macroregions, with Southern Italy being the least trustworthy (five sites in total). Three crops are found on 62.5-75% of the Central Italian sites: common wheat, barley and emmer. Other cereals are present, but less ubiquitously. The cereal triad aforementioned seems to be diffused in the south as well. Conversely, in Northern Italy common wheat and barley were indeed important cultivations but had to compete with other cereals including millet, sorghum, and rye. The latter had a significant increase, being present on almost 30% of the Northern sites (as opposed to the Roman 15%). The **Early Medieval age** seems to mark a shift in Italian agricultural practices, as cereal ubiquities are much more variable regionally. In Southern Italy, the triad of common wheat, barley and emmer were still the predominant cereals. These cereals are ubiquitous in Central and Northern Italy as well, although these regions adopt polyculture with a diversified number of cereals. The samples from the **Medieval age** are fewer in number since the upper boundary of this project's chronology is the 11^th^ c. Despite the short chronology, it is possible to make some considerations. Medieval Centraly Italy relied heavily on common wheat, barley and emmer, with other cereals increasingly important. Barley is the most ubiquitous cereal in Northern Italy in this period, followed by common wheat, millets and sorghum.

```{r}
#| echo: false
#| label: fig-heatmap-ubiquity-cereals-macroreg
#| fig-cap: "Diachronical heatmap of cereals in the Italian macroregions"
#| fig-dpi: 300 

Cereals_Ubiquity_MacroReg_Patchwork

```

#### Legumes

In the **Roman Age**, pulses are an important part of the diet and are cultivated both in Northern and Southern Italy. In the latter, vetch/broad beans are present in 22-32% of the samples, and lentils are present in 38% of the sites. In the **Late Roman Age**, broad beans are equally important in Central and Northern Italy, and peas are present in 50% of the Central Italian sites. In the **Early Medieval Age**, pulses are present in many Central Italian sites, especially blue/red peas, broad beans and other Fabaceae. Lentils and broad beans are also cultivated in almost half of the Northern Italian sites. The importance of pulses in Central Italy is confirmed by the **11^th^ c.** samples, where every specie is present in over 66% of the sites and Fabaceae and blue/red peas are found in every sample. Conversely, in Northern Italy broad bean is found in 66% of the sites.

```{r}
#| echo: false
#| label: fig-heatmap-ubiquity-pulses-macroreg
#| fig-cap: "Diachronical heatmap of pulses in the Italian macroregions" 

Pulses_Ubiquity_MacroReg_Patchwork

```

#### Fruits and nuts

Olive and grape are two essential cultivations in the Italian peninsula. Olive pits, as can be expected, are more ubiquitous in Southern Italy, where in Roman times are present in \>87% of the sites and in over 58% of the sites in the following chronologies[^archaeobotany-1]. Conversely, grape is important in Central and Northern Italy in the Late Roman, Early Medieval and Medieval ages.

[^archaeobotany-1]: The Late Roman values for Southern Italy are only based on 5 samples (3 of which are from the same site, Salapia) so the values are not very trustworthy.

```{r}
#| echo: false
#| label: fig-heatmap-ubiquity-fruit-macroreg
#| fig-cap: "Diachronical heatmap of fruits/nuts in the Italian macroregions" 

FrNuts_Ubiquity_MacroReg_Patchwork

```

## Site richness and diversity by chronology

::: callout-tip
Make sure to cite @nagendra2002 to explain why the indices show different results.
:::

Species richness is a measure used in ecology consisting simply in the counts of species found at a certain location. In archaeology, it can be informative for assessing how many different plants were found at a site. For the calculation, only sites that provided cereals, legumes, fruits and nuts have been used. Although this choice entails the loss of many observations, it was necessary in order to produce more credible and comparable results. The graph shows extended credible intervals for groups with fewer observations.

The aim of the following model was to calculate the mean plant richness in each chronology. The distribution chosen for the model is a Poisson distribution, used when counts do not have a fixed upper boundary (as it is the case of a binomial distribution, for instance). The outcome variable is the richness ($R_{i}$) for each site ${i}$, calculated as follows

$$ R_{i} = \sum_{n=1}^{k} Species_{ni}$$ where $k$ is the total number of species in a site. The goal is then to model the mean richness $\lambda_{i}$. In addition to calculating four intercepts, one for each chronology $ChrID$, the regression also includes a varying slope for each observation ($\beta_{[Observations]}$). This will later be informative in quantifying on average how much the observations in each chronology deviate from the mean ($\alpha_{[ChrID]}$). The formula for the Poisson regression is as follows, where priors for the intercept and slope have been chosen to be weakly informative, so that the range of the possible $\lambda_{i}$ will remain in the outcome space.

$$R_{i} \sim Poisson({\lambda}_{i})$$

$$log {\lambda}_{i} = \alpha_{[ChrID]} + \beta_{[Observations]}$$ $$\alpha_{[ChrID]} \sim Normal(3,0.5)$$ $$\beta_{[Observations]} \sim Normal(0,0.2)$$

```{r}
#| echo: false

plot(
  density(
rpois(1000, exp(rnorm(1e4, 3, 0.5)+rnorm(1e4,0,0.2)))
    ), 
main="Prior Predictive Simulation", 
sub="Exponential(Normal(3,05)+Normal(0,0.2))",
col=rangi2, xlim=c(0,100))

```

```{r}
#| echo: false

##################
# SITE DIVERSITY #
##################

Plants_Diversity <- Archaeobot_Condensed[,-c(2:4,9:13)]

# Subset only complete cases (rows with cereals, fruits, legumes)
# This takes down the counts from 234 to 138, but at least it is more valid
Plants_Diversity <- Plants_Diversity[(Plants_Diversity$Tot..Cereals > 0) & (Plants_Diversity$Tot..Pulses > 0) & (Plants_Diversity$Tot..Fruits.Nuts > 0),]

Plants_Diversity[is.na(Plants_Diversity)] <- 0

# Create two diversity indexes 
Plants_Diversity$Diversity_Simpson = diversity(Plants_Diversity[,c(6:ncol(Plants_Diversity))], 
                                               equalize.groups = T,
                                               MARGIN = 1,
                                               index="simpson"
                                               )
# Calculate the Equitability index so that is normalised to 0-1 as the Simpson
Plants_Diversity$Diversity_Shannon_Eq = diversity(Plants_Diversity[,c(6:ncol(Plants_Diversity))], 
                                               equalize.groups = T,
                                               MARGIN = 1,
                                               index="shannon"
                                               )/log(
                                                 specnumber(Plants_Diversity[,c(6:ncol(Plants_Diversity))])
                                               )
```

```{r}
#| echo: false
#| eval: true
#| message: false
#| output: false

# Create a list for ULAM

# Create a list for STAN
dat.Plants_Diversity = list(
  Diversity_Shannon_Eq = Plants_Diversity$Diversity_Shannon_Eq,
  Diversity_Simpson = Plants_Diversity$Diversity_Simpson,
  Chronology = factor(Plants_Diversity$Chronology),
  Observations = (1:nrow(Plants_Diversity))
)

# Creating a dataframe to count the richness
Plants_Diversity_for_Richness <- Plants_Diversity
Plants_Diversity_for_Richness <- Plants_Diversity_for_Richness[, -c(15,16,25,24,48:50)]
Plants_Diversity_for_Richness[,6:43] <- decostand(Plants_Diversity_for_Richness[,6:43], method="pa")
Plants_Diversity_for_Richness$Richness = rowSums(Plants_Diversity_for_Richness[, c(6:43)])

  
dat.Plants_Richness = list(
  Richness = Plants_Diversity_for_Richness$Richness,
  Chronology = factor(Plants_Diversity_for_Richness$Chronology),
  Observations = (1:nrow(Plants_Diversity_for_Richness))
)


```

```{r}
#| message: false
#| output: false
#| echo: false
#| eval: false


########################################
# Running the models
# Saving the models
# Setting code chunk to eval: false
# To save up on rendering time
########################################

set.seed(24)

Plants_Richness_by_Chronology_fit <- 
  ulam(
    alist(
        Richness ~ dpois( p ),
        log(p) <- a[Chronology] + b[Observations],
        a[Chronology] ~ dnorm(3,0.5),
        b[Observations] ~ dnorm(0,0.2)
    ), data=dat.Plants_Richness , chains=4 , log_lik=TRUE )


Plants_Diversity_Shannon_by_Chronology_fit <- 
  ulam(
   alist(
        Diversity_Shannon_Eq ~ dbeta2( mu , theta ),
        logit(mu) <- a[Chronology],
        a[Chronology] ~ dnorm( 0 , 1.5),
        transpars> theta <<- phi + 2.0,
        phi ~ dexp(0.1)
    ), data=dat.Plants_Diversity, iter=4000, chains=4
    )

Plants_Diversity_Simpson_by_Chronology_fit <- 
  ulam(
   alist(
        Diversity_Simpson ~ dbeta2( mu , theta ),
        logit(mu) <- a[Chronology],
        a[Chronology] ~ dnorm( 0 , 1.5),
        transpars> theta <<- phi + 2.0,
        phi ~ dexp(0.1)
     ), data=dat.Plants_Diversity , chains=4, iter = 4000
    )

saveRDS(Plants_Richness_by_Chronology_fit, "stan_models/by_Chronology/Plants_Richness_by_Chronology_fit.rds")
saveRDS(Plants_Diversity_Shannon_by_Chronology_fit, "stan_models/by_Chronology/Plants_Diversity_Shannon_by_Chronology_fit.rds")
saveRDS(Plants_Diversity_Simpson_by_Chronology_fit, "stan_models/by_Chronology/Plants_Diversity_Simpson_by_Chronology_fit.rds")

```

```{r}
#| echo: false

# Read RDS
Plants_Richness_by_Chronology_fit <- readRDS("stan_models/by_Chronology/Plants_Richness_by_Chronology_fit.rds")
Plants_Diversity_Shannon_by_Chronology_fit <- readRDS("stan_models/by_Chronology/Plants_Diversity_Shannon_by_Chronology_fit.rds")
Plants_Diversity_Simpson_by_Chronology_fit <- readRDS("stan_models/by_Chronology/Plants_Diversity_Simpson_by_Chronology_fit.rds")

# Plots
chrono_levels <- c("R", "LR", "EMA", "Ma")

Plants_Richness_by_Chronology_fit_a <- Plants_Richness_by_Chronology_fit %>%
  spread_draws(a[Chronology]) %>% 
    mutate(Chronology = case_when(
    Chronology == 1 ~ "EMA",
    Chronology == 2 ~ "LR",
    Chronology == 3 ~ "Ma",
    Chronology == 4 ~ "R"
  ))

Plants_Richness_by_Chronology_fit_b <- Plants_Richness_by_Chronology_fit %>%
  spread_draws(b[Observations])

Plants_Richness_by_Chronology_fit_b_Means <- aggregate(Plants_Richness_by_Chronology_fit_b$b, 
                   by = list(Plants_Richness_by_Chronology_fit_b$Observations), 
                   FUN = mean)

Plants_Richness_by_Chronology_fit_b_Means$x <- exp(Plants_Richness_by_Chronology_fit_b_Means$x)

Plants_Richness_by_Chronology_fit_b_Means$Chronology <- Plants_Diversity_for_Richness$Chronology

colnames(Plants_Richness_by_Chronology_fit_b_Means) <- c("Observation", "b", "Chronology")

Plants_Diversity_Shannon_by_Chronology_fit_a <- Plants_Diversity_Shannon_by_Chronology_fit %>%
  spread_draws(a[Chronology]) %>% 
    mutate(Index="Shannon_Eq") %>% 
    mutate(Chronology = case_when(
    Chronology == 1 ~ "EMA",
    Chronology == 2 ~ "LR",
    Chronology == 3 ~ "Ma",
    Chronology == 4 ~ "R"
  ))

Plants_Diversity_Simpson_by_Chronology_fit_a <- Plants_Diversity_Simpson_by_Chronology_fit %>%
  spread_draws(a[Chronology]) %>% 
    mutate(Index="Simpson") %>% 
    mutate(Chronology = case_when(
    Chronology == 1 ~ "EMA",
    Chronology == 2 ~ "LR",
    Chronology == 3 ~ "Ma",
    Chronology == 4 ~ "R"
  ))

Plants_Diversity_Indices_by_Chronology_Means <- data.frame(
  Index=c("Shannon_Eq", "Simpson"),
  means=c(
   mean(Plants_Diversity_Shannon_by_Chronology_fit_a$a),
   mean(Plants_Diversity_Simpson_by_Chronology_fit_a$a)
    )
)

Plants_Diversity_Indices_by_Chronology_fit_a <- bind_rows(Plants_Diversity_Shannon_by_Chronology_fit_a,Plants_Diversity_Simpson_by_Chronology_fit_a)

```

```{r}
#| echo: false

Plants_Richness_by_Chronology_fit_a %>%
  ggplot(aes(
    y = factor(Chronology, levels = chrono_levels),
    x = exp(a)
  )) +
  stat_interval(.width = c(.50, .80, .95, .99),
                linewidth = 3) +
  stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
    geom_vline(
    aes(xintercept = exp(mean( Plants_Richness_by_Chronology_fit_a$a))),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10),
                     sec.axis = dup_axis()) +
  scale_y_discrete(limits = rev) +
  scale_color_brewer(palette = "Greys", name = "Credible interval") +
  labs(
    x = "Predicted number of taxa",
    y = "Chronology",
    title = "Plant Richness"
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  )

Plants_Richness_by_Chronology_fit_b_Means %>%
  ggplot(aes(
    y = factor(Chronology, levels = chrono_levels),
    x = b
  )) +
  geom_boxplot(width = 0.2, alpha = 0.6) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10),
                     sec.axis = dup_axis()) +
  scale_y_discrete(limits = rev) +
  scale_color_brewer(palette = "Greys", name = "Credible interval") +
  labs(
    x = "B (Slope)",
    y = "Chronology",
    title = "Plant Richness - Varying effect",
    caption = "Predicted deviations from the mean, plotted by chronology."
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  )

```

In contrast to richness, diversity takes into account also each taxon's abundance. It is important to notice that in this dataset this figure can be particularly biased by samples that are extremely dominated by one taxon. For instance, if a sample was collected in a processing area or in a storage it is likely to see one taxon dominating the others. Although this was the reason for choosing to work with presence or absence data in this project, diversity indices are still provided for thoroughness' sake. In particular, two indices have been calculated---the Shannon equitability (H') and Simpson indices, both ranging from 0 (for complete unevenness) to 1 (maximum diversity). The ecology R package `vegan` contains functions to perform these calculations. As for the case of richness, only complete observations (containing cereals, pulses, and fruits/nuts) have been taken into account. After calculating both indices for each sample, these values have been modelled both using a beta distribution as follows $$ D_{i} \sim Beta(\mu_{i}, \phi_{i}) $$ $$logit(\mu_{i}) = a_{[ChrID]}$$ $$a_{[ChrID]} \sim Normal(0,1.5)$$ $$\phi_{i} \sim Exp(0.1)+2$$

```{r}
#| echo: false
plot(
  density(
  rbeta2(1000, 
         inv_logit(rnorm(1e4,0,1.5)), 
         rexp(1000, 0.1)+2
         )
  ),
  main="Prior Predictive Simulation", 
col=rangi2, xlim=c(0,1)
)

```

The graph shows extended credible intervals for groups (chronologies) with fewer observations. In particular, the Shannon equitability index showed higher variability in the 11^th^ century. Consequently, its credible range is very wide.

```{r}
#| echo: false


Plants_Diversity_Indices_by_Chronology_fit_a %>%
  ggplot(aes(
    y = factor(Chronology, levels = chrono_levels),
    x = inv_logit(a)
  )) +
  stat_interval(.width = c(.50, .80, .95, .99),
                linewidth = 3) +
  stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
    geom_vline(
    data = Plants_Diversity_Indices_by_Chronology_Means,
    aes(xintercept = inv_logit(means)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10),
                     sec.axis = dup_axis()) +
  scale_y_discrete(limits = rev) +
  scale_color_brewer(palette = "Greys", name = "Credible interval") +
  labs(
    x = "Predicted probability",
    y = "Chronology",
    title = "Plant Diversity"
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) + facet_wrap(Index~.,
  ncol = 1,
  strip.position = "right")

```



## Context type {style="text-align:justify"}

::: callout-note
Important: This section has to be rewritten as now the approach is not frequentist anymore.
:::

It is possible to examine the distribution of plants across different site types during the four phases under examination. During the Roman period, wheat and barley were most prevalent on rural and religious sites, in the latter being used as part of ritual offerings. Minor grains were widely distributed on religious and urban sites, with rural sites and villas also showing high percentages. Legumes were also used in religious offerings but were found on both urban and rural sites. Grapes were ubiquitous across all Roman sites, with particularly high percentages in urban contexts and being extensively cultivated in large Roman estates. Olives had lower percentages, as they cannot be grown in Northern Italy, where most of the samples were collected. However, they were still widely distributed across all contexts, with peak percentages in urban and religious sites. In the Late Roman period, olive presence significantly decreased in urban sites and villas, but remained relatively unchanged in rural contexts. Similarly to olives, grape decrease in the same contexts, but slightly increase in rural sites. In addition to rural sites, grapes are also diffused in over 66% of the fortified sites (*castra*) that start to appear in this period. It is noteworthy that fortified sites from the Late Roman period exhibit high percentages of both minor and noble grains, possibly being stocked with the addition of pulses such as faba beans and vetch. In the EMA phase, noble/minor grains and pulses are still present in almost any fortified sites, a situation that is similar to the one in rural sites. In rural sites however minor grains (40%) and pulses (32%) are less ubiquitous in this period, although this figure might suffer from sites that only published cereal remains. Grapes are present in every religious/funerary context, followed by fortified (71%) and rural sites (66%). If olive cultivation seem to decrease in this phase, it might be because most of the sites with archaeobotanical remains are located in Northern Italy. Olives are present in 50% of the religious sites and on 36% of villa sites. Olives are absent from fortified sites in all phases, probably as a reflection of the northern location of these sites. Both rural and urban sites increase the consumption of berries in this period (13-14% ca.), which are also used for funerary offerings (14%).

::: callout-note
Important: The new section will start from here.
:::

To estimate the probability of occurrence of one (or more) taxa in each chronology and context, I used a Binomial distribution. The $F$ (short for 'found') on the left side of the formula is the outcome variable---a presence/absence indicator for the observation $i$. In the case of a single taxon, the value can either be 0 (for absence) or 1 (for presence) and the $T$ is 1, making the Binomial distribution effectively a Bernoulli distribution. If the model is for more than a single taxon, the $T$ is the total number of taxa that are being modelled. For instance, in the case of 'Noble Grains', the model is trying to assess the probability that common wheat and barley will be on a site type in a certain chronology. The $T$ value for noble grains will then be 2. The outcome variable $F$ indicates the number of types of noble grains found on a particular site $i$, and it can have values ranging from 0 (no noble grains found) to 2 (the site has both barley and common wheat). Although this is not the common way to use a binomial distribution, it was a necessary adjustment as I am working with presence/absence data. The model presented below is an intercept-only model, where the intercept $\alpha$ carries an interaction index ${[TCid]}$ as the model will provide estimates for each context type and chronology under examination.

$$
F_{i} \sim Binomial(T, \bar{p}_{i} )
$$

$$
logit(\bar{p}_{i}) = \alpha_{[TCid]}
$$

$$
\alpha_{[TCid]} \sim Normal(0,1.5)
$$ The rationale behind choosing a normally distributed prior for the intercept $a$ is that it is weakly informative. Below, a simulation of the intercept prior.

```{r}
#| echo: false
#| label: fig-prior-pred-context-type
#| fig-cap: "Prior predictive simulation for the binomial models used in this section. If for instance we want to know how many minor grains (out of seven types) each site was adopting, this prior is weakly informative because it shows no trends."

simplehist(rbinom(1000, size=7, inv_logit(rnorm(1e4, 0, 1.5))),
           xlab="Taxa", 
           main="Prior Predictive Simulation", 
           sub="rbinom(size=2, inv_logit(rnorm(1e4, 0, 1.5))",
           col=rangi2)


```

```{r}
#| echo: false
#| eval: false
                                                                
# Store a copy of the original dataframe
Plants_Df_for_Ubiquity <- Df_Cond_Plants 

# Simplify categories
#table(Plants_Df_for_Ubiquity$Type)
Plants_Df_for_Ubiquity$Type <- str_replace(Plants_Df_for_Ubiquity$Type, "Religious, monastery", "Religious")    
Plants_Df_for_Ubiquity$Type <- str_replace(Plants_Df_for_Ubiquity$Type, "Castle", "Fortified")    
Plants_Df_for_Ubiquity$Type <- str_replace(Plants_Df_for_Ubiquity$Type, "Castrum", "Fortified")  

# Remove unsp.. columns
Plants_Df_for_Ubiquity <- Plants_Df_for_Ubiquity %>% select(-"Unsp..cereals", -"Unsp..Pulses")

# Define types and chrono
Roman_Site_types <- c("Necropolis", "Religious", "Rural", "Rural site, villa", "Urban")
LateRoman_Site_types <- c("Fortified", "Necropolis", "Rural", "Rural site, villa", "Urban")
EMA_Site_types <- c("Fortified", "Necropolis", "Religious", "Rural", "Rural site, villa", "Urban")
Ma_Site_types <- c("Fortified", "Religious", "Rural", "Urban")

# Define a list of column groups
plants_groups <- list(
  Noble.Grains = c("Common.Wheat", "Barley"),
  Minor.Grains = c("Emmer", "Einkorn", "Oats", "Rye", "Proso.millet", "Foxtail.millet", "Sorghum"),
  Legumes= c("Lentil","Pea","Faba.bean","Vetch","Unsp..Vicia","Blue.Red.Pea","Chickpea"),
  Nuts = c("Walnut", "Hazelnut", "Chestnut"),
  Pome.fruits = c("Apple", "Pear"),
  Stone.fruits = c("Peach", "Plum", "Sour.Cherry", "Unsp..Prunus"),
  Berries = c("Blackberry", "Elderberry", "Blackthorn", "Wild.Cherry", "Corn..Cherry", "Sorbus.sp.", "Strawberry"),
  Other.fruits = c("Date", "Melon", "Fig")
)

# Chronology: Roman (R)
Ubiquity_typology_chronology.Roman <- Roman_Site_types %>% 
  map_df(~create_ubiquity_df(Plants_Df_for_Ubiquity, .x, "R"))

# Iterate over the column groups
for (name in names(plants_groups)) {
  
  # Calculate the mean of the columns in the group
  Ubiquity_typology_chronology.Roman <- Ubiquity_typology_chronology.Roman %>%
    mutate(!!name := rowMeans(select(., !!plants_groups[[name]]))) %>% 
                      select(-!!plants_groups[[name]])
}

Ubiquity_typology_chronology.Roman$Chronology <- "R"
Ubiquity_typology_chronology.Roman$Type <- rownames(Ubiquity_typology_chronology.Roman)
rownames(Ubiquity_typology_chronology.Roman) <- NULL

# Chronology: Late Roman (LR)
Ubiquity_typology_chronology.LateRoman <- LateRoman_Site_types %>% 
  map_df(~create_ubiquity_df(Plants_Df_for_Ubiquity, .x, "LR"))

# Iterate over the column groups
for (name in names(plants_groups)) {
  
  # Calculate the mean of the columns in the group
  Ubiquity_typology_chronology.LateRoman <- Ubiquity_typology_chronology.LateRoman %>%
    mutate(!!name := rowMeans(select(., !!plants_groups[[name]]))) %>% 
                      select(-!!plants_groups[[name]])
}

Ubiquity_typology_chronology.LateRoman$Chronology <- "LR"
Ubiquity_typology_chronology.LateRoman$Type <- rownames(Ubiquity_typology_chronology.LateRoman)
rownames(Ubiquity_typology_chronology.LateRoman) <- NULL

# Chronology: Early Medieval (EMA)
Ubiquity_typology_chronology.EMA <- EMA_Site_types %>% 
  map_df(~create_ubiquity_df(Plants_Df_for_Ubiquity, .x, "EMA"))

# Iterate over the column groups
for (name in names(plants_groups)) {
  
  # Calculate the mean of the columns in the group
  Ubiquity_typology_chronology.EMA <- Ubiquity_typology_chronology.EMA %>%
    mutate(!!name := rowMeans(select(., !!plants_groups[[name]]))) %>% 
                      select(-!!plants_groups[[name]])
}

Ubiquity_typology_chronology.EMA$Chronology <- "EMA"
Ubiquity_typology_chronology.EMA$Type <- rownames(Ubiquity_typology_chronology.EMA)
rownames(Ubiquity_typology_chronology.EMA) <- NULL

# Chronology: Medieval (Ma)
Ubiquity_typology_chronology.Ma <- Ma_Site_types %>% 
  map_df(~create_ubiquity_df(Plants_Df_for_Ubiquity, .x, "Ma"))

# Iterate over the column groups
for (name in names(plants_groups)) {
  
  # Calculate the mean of the columns in the group
  Ubiquity_typology_chronology.Ma <- Ubiquity_typology_chronology.Ma %>%
    mutate(!!name := rowMeans(select(., !!plants_groups[[name]]))) %>% 
                      select(-!!plants_groups[[name]])
}

Ubiquity_typology_chronology.Ma$Chronology <- "Ma"
Ubiquity_typology_chronology.Ma$Type <- rownames(Ubiquity_typology_chronology.Ma)
rownames(Ubiquity_typology_chronology.Ma) <- NULL


Ubiquity_All_Chrono_Type <- rbind(
  Ubiquity_typology_chronology.Roman,
  Ubiquity_typology_chronology.LateRoman,
  Ubiquity_typology_chronology.EMA,
  Ubiquity_typology_chronology.Ma
)

# Reorder columns
Ubiquity_All_Chrono_Type <- Ubiquity_All_Chrono_Type %>%
  select("Chronology", "Type", "Noble.Grains","Minor.Grains","Legumes","Nuts","Pome.fruits","Stone.fruits","Berries","Other.fruits","Flax","Grape","Olive")

# PLOTS
level_order <- c("R", "LR", "EMA", "Ma") 
library(ggpubr)

noblegrains_by_type <- ggplot(data=Ubiquity_All_Chrono_Type, 
       aes(
         fill=factor(Chronology, levels=level_order),
         x=Type,
         y=Noble.Grains, 
         ), 
       ) +
        geom_bar(position="dodge", stat="identity") + 
        theme_pubclean() + 
        theme(legend.position="top") +
        scale_fill_grey() +
        labs(
          title = "Noble Grains",
          x= "",
          y = "%",
        fill="Chronology"
    )

minorgrains_by_type <- ggplot(data=Ubiquity_All_Chrono_Type, 
       aes(
         fill=factor(Chronology, levels=level_order),
         x=Type,
         y=Minor.Grains, 
         ), 
       ) +
        geom_bar(position="dodge", stat="identity") + 
        theme_pubclean() + 
        theme(legend.position="none") +
        scale_fill_grey() +
        labs(
          title = "Minor Grains",
          x= "",
          y = "%",
        fill="Chronology"
    )

legumes_by_type <- ggplot(data=Ubiquity_All_Chrono_Type, 
       aes(
         fill=factor(Chronology, levels=level_order),
         x=Type,
         y=Legumes, 
         ), 
       ) +
        geom_bar(position="dodge", stat="identity") + 
        theme_pubclean() + 
        theme(legend.position="none") +
        scale_fill_grey() +
        labs(
          title = "Legumes",
          x= "",
          y = "%",
        fill="Chronology"
    )

grape_by_type <- ggplot(data=Ubiquity_All_Chrono_Type, 
       aes(
         fill=factor(Chronology, levels=level_order),
         x=Type,
         y=Grape, 
         ), 
       ) +
        geom_bar(position="dodge", stat="identity") + 
        theme_pubclean() + 
        theme(legend.position="none") +
        scale_fill_grey() +
        labs(
          title = "Grape",
          x= "",
          y = "%",
        fill="Chronology"
    )

olive_by_type <- ggplot(data=Ubiquity_All_Chrono_Type, 
       aes(
         fill=factor(Chronology, levels=level_order),
         x=Type,
         y=Olive, 
         ), 
       ) +
        geom_bar(position="dodge", stat="identity") + 
        theme_pubclean() + 
        theme(legend.position="none") +
        scale_fill_grey() +
        labs(
          title = "Olives",
          x= "",
          y = "%",
        fill="Chronology"
    )

nuts_by_type <- ggplot(data=Ubiquity_All_Chrono_Type, 
       aes(
         fill=factor(Chronology, levels=level_order),
         x=Type,
         y=Nuts, 
         ), 
       ) +
        geom_bar(position="dodge", stat="identity") + 
        theme_pubclean() + 
        theme(legend.position="none") +
        scale_fill_grey() +
        labs(
          title = "Nuts",
          x= "",
          y = "%",
        fill="Chronology"
    )

pomefruits_by_type <- ggplot(data=Ubiquity_All_Chrono_Type, 
       aes(
         fill=factor(Chronology, levels=level_order),
         x=Type,
         y=Pome.fruits, 
         ), 
       ) +
        geom_bar(position="dodge", stat="identity") + 
        theme_pubclean() + 
        theme(legend.position="bottom") +
        scale_fill_grey() +
        labs(
          title = "Pome Fruits",
          x= "",
          y = "%",
        fill="Chronology"
    )

stonefruits_by_type <- ggplot(data=Ubiquity_All_Chrono_Type, 
       aes(
         fill=factor(Chronology, levels=level_order),
         x=Type,
         y=Stone.fruits, 
         ), 
       ) +
        geom_bar(position="dodge", stat="identity") + 
        theme_pubclean() + 
        theme(legend.position="none") +
        scale_fill_grey() +
        labs(
          title = "Stone Fruits",
          x= "",
          y = "%",
        fill="Chronology"
    )

```

```{r}
#| echo: false
#| warning: false
#| message: false

# Note: The code has to be cleaned because this is a new update and it is not related to the plots used just above this code. 
# For the moment, I will start from scratch
library(dplyr)

Df_Cond_Plants.pa <- Df_Cond_Plants
Df_Cond_Plants.pa[,c(11:50)] <- decostand(Df_Cond_Plants.pa[,c(11:50)], method="pa", na.rm = T)

Df_Cond_Plants.pa[is.na(Df_Cond_Plants.pa)] <- 0

#Simplify categories
Df_Cond_Plants.pa$Type <- str_replace(Df_Cond_Plants.pa$Type, "Religious, monastery", "Religious")    
Df_Cond_Plants.pa$Type <- str_replace(Df_Cond_Plants.pa$Type, "Castle", "Fortified")    
Df_Cond_Plants.pa$Type <- str_replace(Df_Cond_Plants.pa$Type, "Castrum", "Fortified")  

```

```{r}
#| echo: false
#| eval: true
#| code-fold: true

Minor_Grains <- with(
  Df_Cond_Plants.pa,
  data.frame(
  Chronology = Chronology,
  From.Century=From.Century, 
  To.Century=To.Century,
  Macroregion = name_macroreg,
  Site_Type = as.factor(Type),
  Geo = Geo,
  Grain_Count = Einkorn+Oats+Rye+Proso.millet+Foxtail.millet+Sorghum+Emmer,
  All_Grain_Count = rowSums(Df_Cond_Plants.pa[,c(11:19)])
  )
)

# Transform categories to factors
Minor_Grains[,c(1,4,5,6)] <- lapply(Minor_Grains[,c(1,4,5,6)], factor)

Noble_Grains_Reg <- with(
  Df_Cond_Plants.pa,
  data.frame(
  Chronology = Chronology,
  From.Century=From.Century, 
  To.Century=To.Century,
  Macroregion = name_macroreg,
  Site_Type = as.factor(Type),
  Geo = Geo,
  Grain_Count = Common.Wheat+Barley,
  All_Grain_Count = rowSums(Df_Cond_Plants.pa[,c(11:19)])
  )
)

# Transform categories to factors
Noble_Grains_Reg[,c(1,4,5,6)] <- lapply(Noble_Grains_Reg[,c(1,4,5,6)], factor)


```

```{r}
#| echo: true
#| code-fold: true
#| eval: true
#| message: false
#| output: false

library(rethinking)
library(tidybayes.rethinking)
library(tidybayes)

####################
## NOBLE GRAINS
####################

Noble_Grains <- with(
  Df_Cond_Plants.pa,
  data.frame(
  Chronology = Chronology,
  Macroregion = name_macroreg,
  Site_Type = as.factor(Type),
  Geo = Geo,
  Grain_Count = rowSums(Df_Cond_Plants.pa[,c(11,15)])
  )
)

#Simplify categories
Noble_Grains$Site_Type <- str_replace(Noble_Grains$Site_Type, "Religious, monastery", "Religious")    
Noble_Grains$Site_Type <- str_replace(Noble_Grains$Site_Type, "Castle", "Fortified")    
Noble_Grains$Site_Type <- str_replace(Noble_Grains$Site_Type, "Castrum", "Fortified")  

# Convert to list
Noble_Grain.list <- list(
    NG_Found = Noble_Grains$Grain_Count,
    NG_Tot = 2,
    TC_ID = as.factor((interaction(Noble_Grains$Chronology, 
                                   Noble_Grains$Site_Type)))
   )

Noble_Grain.list$TC_ID <- droplevels(Noble_Grain.list$TC_ID)


####################
## MINOR GRAINS
####################

# Convert to list
Minor_Grains_Type.list <- list(
    MG_Found = Minor_Grains$Grain_Count,
    MG_Tot = 7,
    TC_ID = as.factor((interaction(Minor_Grains$Chronology, 
                                   Minor_Grains$Site_Type)))
   )

Minor_Grains_Type.list$TC_ID <- droplevels(Minor_Grains_Type.list$TC_ID)
  

####################
## LEGUMES 
####################

Legumes <- with(
  Df_Cond_Plants.pa,
  data.frame(
  Chronology = Chronology,
  Macroregion = name_macroreg,
  Site_Type = as.factor(Type),
  Geo = Geo,
  Seed_Count = rowSums(Df_Cond_Plants.pa[,c(21,27)]) # Excludes Unsp. Pulses
  )
)

#Simplify categories
Legumes$Site_Type <- str_replace(Legumes$Site_Type, "Religious, monastery", "Religious")    
Legumes$Site_Type <- str_replace(Legumes$Site_Type, "Castle", "Fortified")    
Legumes$Site_Type <- str_replace(Legumes$Site_Type, "Castrum", "Fortified")  

# Convert to list
Legumes.list <- list(
    Leg_Found = Legumes$Seed_Count,
    Leg_Tot = 7,
    TC_ID = as.factor((interaction(Legumes$Chronology, 
                                   Legumes$Site_Type)))
   )

Legumes.list$TC_ID <- droplevels(Legumes.list$TC_ID)


####################
## GRAPE 
####################

Grape <- with(
  Df_Cond_Plants.pa,
  data.frame(
  Chronology = Chronology,
  Macroregion = name_macroreg,
  Site_Type = as.factor(Type),
  Geo = Geo,
  Present = ifelse(Grape>0, 1, 0)
  )
)

#Simplify categories
Grape$Site_Type <- str_replace(Grape$Site_Type, "Religious, monastery", "Religious")    
Grape$Site_Type <- str_replace(Grape$Site_Type, "Castle", "Fortified")    
Grape$Site_Type <- str_replace(Grape$Site_Type, "Castrum", "Fortified")  

# Convert to list
Grape.list <- list(
    Grape_Found = Grape$Present,
    TC_ID = as.factor((interaction(Legumes$Chronology, 
                                   Legumes$Site_Type)))
   )

Grape.list$TC_ID <- droplevels(Grape.list$TC_ID)
  

####################
## OLIVES 
####################

Olives <- with(
  Df_Cond_Plants.pa,
  data.frame(
  Chronology = Chronology,
  Macroregion = name_macroreg,
  Site_Type = as.factor(Type),
  Geo = Geo,
  Present = ifelse(Olive>0, 1, 0)
  )
)

#Simplify categories
Olives$Site_Type <- str_replace(Olives$Site_Type, "Religious, monastery", "Religious")
Olives$Site_Type <- str_replace(Olives$Site_Type, "Castle", "Fortified")    
Olives$Site_Type <- str_replace(Olives$Site_Type, "Castrum", "Fortified")  

# Convert to list
Olive.list <- list(
    Olive_Found = Olives$Present,
    TC_ID = as.factor((interaction(Olives$Chronology, 
                                   Olives$Site_Type)))
   )

Olive.list$TC_ID <- droplevels(Olive.list$TC_ID)
  

####################
## NUTS 
####################

Nuts <- with(
  Df_Cond_Plants.pa,
  data.frame(
  Chronology = Chronology,
  Macroregion = name_macroreg,
  Site_Type = as.factor(Type),
  Geo = Geo,
  Seed_Count = rowSums(Df_Cond_Plants.pa[,c(29,31)])
  )
)

#Simplify categories
Nuts$Site_Type <- str_replace(Nuts$Site_Type, "Religious, monastery", "Religious")    
Nuts$Site_Type <- str_replace(Nuts$Site_Type, "Castle", "Fortified")    
Nuts$Site_Type <- str_replace(Nuts$Site_Type, "Castrum", "Fortified")  

# Convert to list
Nuts.list <- list(
    Nuts_Found = Nuts$Seed_Count,
    Nuts_Tot = 3,
    TC_ID = as.factor((interaction(Nuts$Chronology, 
                                   Nuts$Site_Type)))
   )

Nuts.list$TC_ID <- droplevels(Nuts.list$TC_ID)
  


```

```{r}
#| echo: true
#| code-fold: true
#| eval: false
# Eval is set to false because the models have been saved

# Create a binomial model, where N is 2 because that is the total number of noble 
# grains studied in this thesis
m_ng_type <- ulam(
   alist(
        NG_Found ~ dbinom( 2 , p ),
        logit(p) <- TypeChr[TC_ID],
        TypeChr[TC_ID] ~ dnorm(0,1.5)
    ), data=Noble_Grain.list , chains=4
    )

saveRDS(m_ng_type, "stan_models/m_ng_type.rds")

# Create a binomial model, where N is 2 because that is the total number of noble 
# grains studied in this thesis
m_mg_type <- ulam(
    alist(
        MG_Found ~ dbinom( 7 , p ),
        logit(p) <- TypeChr[TC_ID],
        TypeChr[TC_ID] ~ dnorm(0,1.5)
    ), data=Minor_Grains_Type.list , chains=4
    )

saveRDS(m_mg_type, "stan_models/m_mg_type.rds")


# Create a binomial model, where N is 2 because that is the total number of noble 
# grains studied in this thesis
m_leg_type <- ulam(
    alist(
        Leg_Found ~ dbinom( 7 , p ),
        logit(p) <- TypeChr[TC_ID],
        TypeChr[TC_ID] ~ dnorm(0,1.5)
    ), data=Legumes.list , chains=4
    )

saveRDS(m_leg_type, "stan_models/m_leg_type.rds")

# Create a binomial model, where N is 2 because that is the total number of noble 
# grains studied in this thesis
m_grape_type <- ulam(
    alist(
        Grape_Found ~ dbinom( 1 , p ), # Basically a bernoulli dist
        logit(p) <- TypeChr[TC_ID],
        TypeChr[TC_ID] ~ dnorm(0,1.5)
    ), data=Grape.list , chains=4
    )

saveRDS(m_grape_type, "stan_models/m_grape_type.rds")

# Create a binomial model, where N is 2 because that is the total number of noble 
# grains studied in this thesis
m_olives_type <- ulam(
    alist(
        Olive_Found ~ dbinom( 1 , p ), # Basically a bernoulli dist
        logit(p) <- TypeChr[TC_ID],
        TypeChr[TC_ID] ~ dnorm(0,1.5)
    ), data=Olive.list , chains=4
    )

saveRDS(m_olives_type, "stan_models/m_olives_type.rds")

# NUTS
# Create a binomial model, where N is 3 because that is the total number of nuts
#  studied in this thesis
m_nuts_type <- ulam(
    alist(
        Nuts_Found ~ dbinom( 3 , p ),
        logit(p) <- TypeChr[TC_ID],
        TypeChr[TC_ID] ~ dnorm(0,1.5)
    ), data=Nuts.list , chains=4
    )
saveRDS(m_nuts_type, "stan_models/m_nuts_type.rds")

# BERRIES
# Create a binomial model
m_berries_type <- ulam(
    alist(
        Berries_Found ~ dbinom( 9 , p ),
        logit(p) <- TypeChr[TC_ID],
        TypeChr[TC_ID] ~ dnorm(0,1.5)
    ), data=Berries_type.list , chains=4
    )

saveRDS(m_berries_type, "stan_models/m_berries_type.rds")

```

```{r}
#| echo: false
#| include: false

## NOBLE GRAINS

m_ng_type<-readRDS("stan_models/m_ng_type.rds")

m_ng_type.df <- m_ng_type %>%
  spread_draws(TypeChr[TC_ID])

m_ng_type.df %>% mutate(Type = case_when(
  TC_ID >= 1 &  TC_ID <= 3 ~ "Fortified",
  TC_ID >= 4 & TC_ID <= 6 ~ "Necropolis",
  TC_ID >= 7 & TC_ID <= 9  ~ "Religious",
  TC_ID >= 10 & TC_ID<=13 ~ "Rural",
  TC_ID >=14 & TC_ID<=16 ~ "Villa",
  TC_ID >=17 & TC_ID <=20 ~ "Urban"
))  %>% mutate(Chrono = case_when(
    TC_ID == 6 | TC_ID==9 |  TC_ID == 13 | TC_ID==16 | TC_ID==20  ~ "R",
    TC_ID == 2 |  TC_ID == 5 | TC_ID == 11 | TC_ID==15 | TC_ID==18  ~ "LR",
    TC_ID == 1 |  TC_ID == 4 | TC_ID == 7 | TC_ID==10 | TC_ID==14 | TC_ID==17  ~ "EMA",
    TC_ID == 3 |  TC_ID == 8 | TC_ID == 12 | TC_ID==19 ~ "Ma"
)) -> m_ng_type.df

m_ng_type.plot <- ggplot(
  data = m_ng_type.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(TypeChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_ng_type.df$TypeChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(Type ~ ., scales = "free") +
  labs(
    title = "Noble Grains",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each site type and chronology.\nThe circle indicates the mean for each line."
  )


```

```{r}
#| echo: false
#| include: false


## MINOR GRAINS
m_mg_type <- readRDS("stan_models/m_mg_type.rds")

m_mg_type.df <- m_mg_type %>%
  spread_draws(TypeChr[TC_ID])

m_mg_type.df %>% mutate(Type = case_when(
  TC_ID >= 1 &  TC_ID <= 3 ~ "Fortified",
  TC_ID >= 4 & TC_ID <= 6 ~ "Necropolis",
  TC_ID >= 7 & TC_ID <= 9  ~ "Religious",
  TC_ID >= 10 & TC_ID<=13 ~ "Rural",
  TC_ID >=14 & TC_ID<=16 ~ "Villa",
  TC_ID >=17 & TC_ID <=20 ~ "Urban"
))  %>% mutate(Chrono = case_when(
    TC_ID == 6 | TC_ID==9 |  TC_ID == 13 | TC_ID==16 | TC_ID==20  ~ "R",
    TC_ID == 2 |  TC_ID == 5 | TC_ID == 11 | TC_ID==15 | TC_ID==18  ~ "LR",
    TC_ID == 1 |  TC_ID == 4 | TC_ID == 7 | TC_ID==10 | TC_ID==14 | TC_ID==17  ~ "EMA",
    TC_ID == 3 |  TC_ID == 8 | TC_ID == 12 | TC_ID==19 ~ "Ma"
)) -> m_mg_type.df


m_mg_type.plot <- ggplot(
  data = m_mg_type.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(TypeChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_mg_type.df$TypeChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(Type ~ ., scales = "free") +
  labs(
    title = "Minor Grains",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each site type and chronology.\nThe circle indicates the mean for each line."
  )


```

```{r}
#| echo: false
#| include: false

## LEGUMES
m_leg_type <- readRDS("stan_models/m_leg_type.rds")

m_leg_type.df <- m_leg_type %>%
  spread_draws(TypeChr[TC_ID])

m_leg_type.df %>% mutate(Type = case_when(
  TC_ID >= 1 &  TC_ID <= 3 ~ "Fortified",
  TC_ID >= 4 & TC_ID <= 6 ~ "Necropolis",
  TC_ID >= 7 & TC_ID <= 9  ~ "Religious",
  TC_ID >= 10 & TC_ID<=13 ~ "Rural",
  TC_ID >=14 & TC_ID<=16 ~ "Villa",
  TC_ID >=17 & TC_ID <=20 ~ "Urban"
))  %>% mutate(Chrono = case_when(
    TC_ID == 6 | TC_ID==9 |  TC_ID == 13 | TC_ID==16 | TC_ID==20  ~ "R",
    TC_ID == 2 |  TC_ID == 5 | TC_ID == 11 | TC_ID==15 | TC_ID==18  ~ "LR",
    TC_ID == 1 |  TC_ID == 4 | TC_ID == 7 | TC_ID==10 | TC_ID==14 | TC_ID==17  ~ "EMA",
    TC_ID == 3 |  TC_ID == 8 | TC_ID == 12 | TC_ID==19 ~ "Ma"
)) -> m_leg_type.df

m_leg_type.plot <- ggplot(
  data = m_leg_type.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(TypeChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_leg_type.df$TypeChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(Type ~ ., scales = "free") +
  labs(
    title = "Legumes",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each site type and chronology.\nThe circle indicates the mean for each line."
  )

```

```{r}
#| echo: false
#| include: false

m_grape_type <- readRDS("stan_models/m_grape_type.rds")

m_grape_type.df <- m_grape_type %>%
  spread_draws(TypeChr[TC_ID])

m_grape_type.df %>% mutate(Type = case_when(
  TC_ID >= 1 &  TC_ID <= 3 ~ "Fortified",
  TC_ID >= 4 & TC_ID <= 6 ~ "Necropolis",
  TC_ID >= 7 & TC_ID <= 9  ~ "Religious",
  TC_ID >= 10 & TC_ID<=13 ~ "Rural",
  TC_ID >=14 & TC_ID<=16 ~ "Villa",
  TC_ID >=17 & TC_ID <=20 ~ "Urban"
))  %>% mutate(Chrono = case_when(
    TC_ID == 6 | TC_ID==9 |  TC_ID == 13 | TC_ID==16 | TC_ID==20  ~ "R",
    TC_ID == 2 |  TC_ID == 5 | TC_ID == 11 | TC_ID==15 | TC_ID==18  ~ "LR",
    TC_ID == 1 |  TC_ID == 4 | TC_ID == 7 | TC_ID==10 | TC_ID==14 | TC_ID==17  ~ "EMA",
    TC_ID == 3 |  TC_ID == 8 | TC_ID == 12 | TC_ID==19 ~ "Ma"
)) -> m_grape_type.df

m_grape_type.plot <- ggplot(
  data = m_grape_type.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(TypeChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_grape_type.df$TypeChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(Type ~ ., scales = "free") +
  labs(
    title = "Grape",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each site type and chronology.\nThe circle indicates the mean for each line."
  )


```

```{r}
#| echo: false
#| include: false

## OLIVES

# Why is it predicting means where there is no data? 

m_olives_type <- readRDS("stan_models/m_olives_type.rds")

m_olives_type.df <- m_olives_type %>%
  spread_draws(TypeChr[TC_ID])

m_olives_type.df %>% mutate(Type = case_when(
  TC_ID >= 1 &  TC_ID <= 3 ~ "Fortified",
  TC_ID >= 4 & TC_ID <= 6 ~ "Necropolis",
  TC_ID >= 7 & TC_ID <= 9  ~ "Religious",
  TC_ID >= 10 & TC_ID<=13 ~ "Rural",
  TC_ID >=14 & TC_ID<=16 ~ "Villa",
  TC_ID >=17 & TC_ID <=20 ~ "Urban"
))  %>% mutate(Chrono = case_when(
    TC_ID == 6 | TC_ID==9 |  TC_ID == 13 | TC_ID==16 | TC_ID==20  ~ "R",
    TC_ID == 2 |  TC_ID == 5 | TC_ID == 11 | TC_ID==15 | TC_ID==18  ~ "LR",
    TC_ID == 1 |  TC_ID == 4 | TC_ID == 7 | TC_ID==10 | TC_ID==14 | TC_ID==17  ~ "EMA",
    TC_ID == 3 |  TC_ID == 8 | TC_ID == 12 | TC_ID==19 ~ "Ma"
)) -> m_olives_type.df

m_olives_type.plot <- ggplot(
  data = m_olives_type.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(TypeChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_olives_type.df$TypeChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(Type ~ ., scales = "free") +
  labs(
    title = "Olive",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each site type and chronology.\nThe circle indicates the mean for each line."
  )


```

```{r}
#| echo: false
#| include: false

## NUTS
m_nuts_type <- readRDS("stan_models/m_nuts_type.rds")

m_nuts_type.df <- m_nuts_type %>%
  spread_draws(TypeChr[TC_ID])

m_nuts_type.df %>% mutate(Type = case_when(
  TC_ID >= 1 &  TC_ID <= 3 ~ "Fortified",
  TC_ID >= 4 & TC_ID <= 6 ~ "Necropolis",
  TC_ID >= 7 & TC_ID <= 9  ~ "Religious",
  TC_ID >= 10 & TC_ID<=13 ~ "Rural",
  TC_ID >=14 & TC_ID<=16 ~ "Villa",
  TC_ID >=17 & TC_ID <=20 ~ "Urban"
))  %>% mutate(Chrono = case_when(
    TC_ID == 6 | TC_ID==9 |  TC_ID == 13 | TC_ID==16 | TC_ID==20  ~ "R",
    TC_ID == 2 |  TC_ID == 5 | TC_ID == 11 | TC_ID==15 | TC_ID==18  ~ "LR",
    TC_ID == 1 |  TC_ID == 4 | TC_ID == 7 | TC_ID==10 | TC_ID==14 | TC_ID==17  ~ "EMA",
    TC_ID == 3 |  TC_ID == 8 | TC_ID == 12 | TC_ID==19 ~ "Ma"
)) -> m_nuts_type.df


m_nuts_type.plot <- ggplot(
  data = m_nuts_type.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(TypeChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_nuts_type.df$TypeChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(Type ~ ., scales = "free") +
  labs(
    title = "Nuts",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each site type and chronology.\nThe circle indicates the mean for each line."
  )

```

```{r}
#| echo: false
#| include: false

## Stone fruits
#Berries = c("Blackberry", "Elderberry", "Blackthorn", "Wild.Cherry", "Corn..Cherry", "Sorbus.sp.", "Strawberry"),
#  Stone.fruits = c("Peach", "Plum", "Sour.Cherry", "Unsp..Prunus"),


DomFruit <- with(
  Df_Cond_Plants.pa,
  data.frame(
  Chronology = Chronology,
  Macroregion = name_macroreg,
  Site_Type = as.factor(Type),
  Geo = Geo,
  Seed_Count = rowSums(Df_Cond_Plants.pa[,c(32,33,35:38,50)])
  )
)

#Simplify categories
DomFruit$Site_Type <- str_replace(DomFruit$Site_Type, "Religious, monastery", "Religious")
DomFruit$Site_Type <- str_replace(DomFruit$Site_Type, "Castle", "Fortified")    
DomFruit$Site_Type <- str_replace(DomFruit$Site_Type, "Castrum", "Fortified")  

# Convert to list
DomFruit.list <- list(
    DF_Found = DomFruit$Seed_Count,
    DF_Tot = 7,
    TC_ID = as.factor((interaction(DomFruit$Chronology, 
                                   DomFruit$Site_Type)))
   )

DomFruit.list$TC_ID <- droplevels(DomFruit.list$TC_ID)

### BERRIES

Berries <- with(
  Df_Cond_Plants.pa,
  data.frame(
  Chronology = Chronology,
  Macroregion = name_macroreg,
  Site_Type = as.factor(Type),
  Geo = Geo,
  Seed_Count = rowSums(Df_Cond_Plants.pa[,c(41:49)])
  )
)

#Simplify categories
Berries$Site_Type <- str_replace(Berries$Site_Type, "Religious, monastery", "Religious")
Berries$Site_Type <- str_replace(Berries$Site_Type, "Castle", "Fortified")    
Berries$Site_Type <- str_replace(Berries$Site_Type, "Castrum", "Fortified")  

# Convert to list
Berries_type.list <- list(
    Berries_Found = Berries$Seed_Count,
    DF_Tot = 9,
    TC_ID = as.factor((interaction(Berries$Chronology, 
                                   Berries$Site_Type)))
   )

Berries_type.list$TC_ID <- droplevels(Berries_type.list$TC_ID)

Berries_reg.list <- list(
    Berries_Found = Berries$Seed_Count,
    DF_Tot = 9,
    RC_ID = as.factor((interaction(Berries$Chronology, 
                                   Berries$Macroregion)))
   )

Berries_reg.list$RC_ID <- droplevels(Berries_reg.list$RC_ID)

```

```{r}
#| eval: false
#| echo: false

####################
## Domestic FRUITS 
####################

# Create a binomial model, where N is 3 because that is the total number of noble 
# grains studied in this thesis
m_dfruit_type <- ulam(
    alist(
        DF_Found ~ dbinom( 7 , p ),
        logit(p) <- TypeChr[TC_ID],
        TypeChr[TC_ID] ~ dnorm(0,1.5)
    ), data=DomFruit.list , chains=4
    )

saveRDS(m_dfruit_type, "stan_models/m_dfruit_type.rds")
```

```{r}
#| echo: false

m_dfruit_type <- readRDS("stan_models/m_dfruit_type.rds")

m_dfruit_type.df <- m_dfruit_type %>%
  spread_draws(TypeChr[TC_ID])

m_dfruit_type.df %>% mutate(Type = case_when(
  TC_ID >= 1 &  TC_ID <= 3 ~ "Fortified",
  TC_ID >= 4 & TC_ID <= 6 ~ "Necropolis",
  TC_ID >= 7 & TC_ID <= 9  ~ "Religious",
  TC_ID >= 10 & TC_ID<=13 ~ "Rural",
  TC_ID >=14 & TC_ID<=16 ~ "Villa",
  TC_ID >=17 & TC_ID <=20 ~ "Urban"
))  %>% mutate(Chrono = case_when(
  TC_ID == 6 | TC_ID==9 |  TC_ID == 13 | TC_ID==16 | TC_ID==20  ~ "R",
  TC_ID == 2 |  TC_ID == 5 | TC_ID == 11 | TC_ID==15 | TC_ID==18  ~ "LR",
  TC_ID == 1 |  TC_ID == 4 | TC_ID == 7 | TC_ID==10 | TC_ID==14 | TC_ID==17  ~ "EMA",
  TC_ID == 3 |  TC_ID == 8 | TC_ID == 12 | TC_ID==19 ~ "Ma"
)) -> m_dfruit_type.df


m_dfruit_type.plot <- ggplot(
  data = m_dfruit_type.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(TypeChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_dfruit_type.df$TypeChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(Type ~ ., scales = "free") +
  labs(
    title = "Domestic Fruits",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each site type and chronology.\nThe circle indicates the mean for each line."
  )


m_berries_type <- readRDS("stan_models/m_berries_type.rds")

m_berries_type.df <- m_berries_type %>%
  spread_draws(TypeChr[TC_ID])

m_berries_type.df %>% mutate(Type = case_when(
  TC_ID >= 1 &  TC_ID <= 3 ~ "Fortified",
  TC_ID >= 4 & TC_ID <= 6 ~ "Necropolis",
  TC_ID >= 7 & TC_ID <= 9  ~ "Religious",
  TC_ID >= 10 & TC_ID<=13 ~ "Rural",
  TC_ID >=14 & TC_ID<=16 ~ "Villa",
  TC_ID >=17 & TC_ID <=20 ~ "Urban"
))  %>% mutate(Chrono = case_when(
  TC_ID == 6 | TC_ID==9 |  TC_ID == 13 | TC_ID==16 | TC_ID==20  ~ "R",
  TC_ID == 2 |  TC_ID == 5 | TC_ID == 11 | TC_ID==15 | TC_ID==18  ~ "LR",
  TC_ID == 1 |  TC_ID == 4 | TC_ID == 7 | TC_ID==10 | TC_ID==14 | TC_ID==17  ~ "EMA",
  TC_ID == 3 |  TC_ID == 8 | TC_ID == 12 | TC_ID==19 ~ "Ma"
)) -> m_berries_type.df


m_berries_type.plot <- ggplot(
  data = m_berries_type.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(TypeChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_berries_type.df$TypeChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(Type ~ ., scales = "free") +
  labs(
    title = "Berries",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each site type and chronology.\nThe circle indicates the mean for each line."
  )

```

```{r}
#| echo: false
#| warning: false
#| label: fig-bayes-glm-site-type
#| fig-cap: "Bayesian probability estimates for main plant taxa, divided by site type and chronology.\nThe prediction estimates are produced with a GLM and weakly informative priors. Credible intervals are provided."
#| fig-subcap: 
#|  - "Noble grains (wheat and barley)."
#|  - "Minor grains."
#|  - "Legumes."
#|  - "Grape."
#|  - "Olives. The model is predicting (conservative) values for fortified sites, in which no olive was found."
#|  - "Nuts."
#|  - "Domestic fruits."
#|  - "Berries."
#| layout-nrow: 8
#| layout-ncol: 1
#| fig-height: 10

m_ng_type.plot
m_mg_type.plot
m_leg_type.plot
m_grape_type.plot
m_olives_type.plot
m_nuts_type.plot
m_dfruit_type.plot
m_berries_type.plot

```

### Richness and diversity

```{r}
#| echo: false

####################
# DATA PROCESSING  #
####################

# 1. Remove NAs
Df_Cond_Plants[is.na(Df_Cond_Plants)] <-0 

# 2. Generate a dataframe with the relative proportions and round the results
Df_Cond_Plants_Rel <- decostand(Df_Cond_Plants[11:50], method = "total")
Df_Cond_Plants_Rel <- round(Df_Cond_Plants_Rel, digits=2)

# 3. Create a dataframe with the variables of interest
Df_Cond_Plants_RichnDiv <- data.frame(
  "Geo" = Df_Cond_Plants$Geo,
  "Chronology" = Df_Cond_Plants$Chronology,
  "Type"= Df_Cond_Plants$Type, 
  "Macroregion" = Df_Cond_Plants$name_macroreg,
  "Specnumber" = specnumber(Df_Cond_Plants_Rel), #All plants
  "Shannon Div" = diversity(Df_Cond_Plants_Rel),
  Df_Cond_Plants_Rel
)

# 4. Simplify some categories
Df_Cond_Plants_RichnDiv$Type <- str_replace(Df_Cond_Plants_RichnDiv$Type, "Religious, monastery", "Religious")    
Df_Cond_Plants_RichnDiv$Type <- str_replace(Df_Cond_Plants_RichnDiv$Type, "Castle", "Fortified")    
Df_Cond_Plants_RichnDiv$Type <- str_replace(Df_Cond_Plants_RichnDiv$Type, "Castrum", "Fortified")  

# PLOTS BY TYPE

# Dataframes filtered by Chronology 
Df_Cond_Plants_RichnDiv.R <- filter(Df_Cond_Plants_RichnDiv, Chronology == "R")
Df_Cond_Plants_RichnDiv.LR <- filter(Df_Cond_Plants_RichnDiv, Chronology == "LR")
Df_Cond_Plants_RichnDiv.EMA <- filter(Df_Cond_Plants_RichnDiv, Chronology == "EMA")
Df_Cond_Plants_RichnDiv.Ma <- filter(Df_Cond_Plants_RichnDiv, Chronology == "Ma")


############################################################################
## CORRECTION FOR INCOMPLETE SAMPLES                                       #
# Need to filter out sites that did not provide legumes or fruits at all   #
# Need to compare these rows to see if there are some indexes in common    #
############################################################################

# Chronology: R 
CompleteSamples.R <- data.frame(
Cereals = (rowSums(Df_Cond_Plants_RichnDiv.R[,c(7:16)]) > 0),
Legumes = (rowSums(Df_Cond_Plants_RichnDiv.R[,c(17:30)]) > 0),
Fruits = (rowSums(Df_Cond_Plants_RichnDiv.R[,c(31:46)]) > 0)
)

IncompleteSamplesIndexes.R <- which(rowSums(CompleteSamples.R) < 3)

# Chronology: LR 
CompleteSamples.LR <- data.frame(
Cereals = (rowSums(Df_Cond_Plants_RichnDiv.LR[,c(7:16)]) > 0),
Legumes = (rowSums(Df_Cond_Plants_RichnDiv.LR[,c(17:30)]) > 0),
Fruits = (rowSums(Df_Cond_Plants_RichnDiv.LR[,c(31:46)]) > 0)
)

IncompleteSamplesIndexes.LR <- which(rowSums(CompleteSamples.LR) < 3)

# Chronology: EMA 
CompleteSamples.EMA <- data.frame(
Cereals = (rowSums(Df_Cond_Plants_RichnDiv.EMA[,c(7:16)]) > 0),
Legumes = (rowSums(Df_Cond_Plants_RichnDiv.EMA[,c(17:30)]) > 0),
Fruits = (rowSums(Df_Cond_Plants_RichnDiv.EMA[,c(31:46)]) > 0)
)

IncompleteSamplesIndexes.EMA <- which(rowSums(CompleteSamples.EMA) < 3)

# Chronology: Ma 
CompleteSamples.Ma <- data.frame(
Cereals = (rowSums(Df_Cond_Plants_RichnDiv.Ma[,c(7:16)]) > 0),
Legumes = (rowSums(Df_Cond_Plants_RichnDiv.Ma[,c(17:30)]) > 0),
Fruits = (rowSums(Df_Cond_Plants_RichnDiv.Ma[,c(31:46)]) > 0)
)

IncompleteSamplesIndexes.Ma <- which(rowSums(CompleteSamples.Ma) < 3)

#############################################
## END OF CORRECTION FOR INCOMPLETE SAMPLES #
#############################################

plot_RichnessType.R <- ggplot(Df_Cond_Plants_RichnDiv.R, 
                              aes(x = Type, y = Specnumber, fill = Type)) +
    geom_hline(
    yintercept = mean(Df_Cond_Plants_RichnDiv.R$Specnumber),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  geom_boxplot(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Greys") +
  geom_jitter(alpha = 0.3) +
  scale_x_discrete(labels = c("Necropolis \n (n = 13)", "Religious \n (n = 3)", "Rural \n (n = 12)", "Villa \n (n = 4)", "Urban \n (n = 44)")) +
    scale_y_continuous(
    breaks = scales::pretty_breaks(n = 10)
  ) +
  theme(
    legend.position = "none",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.major.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.minor.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    )
  ) +
  labs(x = "Site type",
       y = "Number of species per site",
       title = "R - Plant Richness")

plot_DiversityType.R <- ggplot(Df_Cond_Plants_RichnDiv.R, aes(x = Type, y = Shannon.Div, fill = Type)) +
    geom_hline(
    yintercept = mean(Df_Cond_Plants_RichnDiv.R$Shannon.Div),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  geom_boxplot(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Greys") +
  geom_jitter(alpha=0.3)+
  scale_x_discrete(labels = c("Necropolis \n (n = 13)", "Religious \n (n = 3)", "Rural \n (n=12)", "Villa \n (n=4)", "Urban \n (n=44)" )) +
    scale_y_continuous(
    breaks = scales::pretty_breaks(n = 10)
  ) +
  theme(
    legend.position = "none",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.major.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.minor.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    )
  ) +
  labs(x = "Site type",
       y = "Site diversity",
       title = "R - Shannon diversity")

plot_RichnessType.LR <- ggplot(Df_Cond_Plants_RichnDiv.LR, aes(x = Type, y = Specnumber, fill = Type)) +
    geom_hline(
    yintercept = mean(Df_Cond_Plants_RichnDiv.LR$Specnumber),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  geom_boxplot(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Greys") +
  geom_jitter(alpha=0.3)+
  scale_x_discrete(labels = c("Fortified \n (n=3)", "Necropolis \n (n = 10)", "Rural \n (n=14)", "Villa \n (n=11)", "Urban \n (n=24)" )) +
    scale_y_continuous(
    breaks = scales::pretty_breaks(n = 10)
  ) +
  theme(
    legend.position = "none",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.major.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.minor.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    )
  ) +
  labs(x = "Site type",
       y = "Number of species per site",
       title = "LR - Plant richness")

plot_DiversityType.LR <- ggplot(Df_Cond_Plants_RichnDiv.LR, aes(x = Type, y = Shannon.Div, fill = Type)) +
    geom_hline(
    yintercept = mean(Df_Cond_Plants_RichnDiv.LR$Shannon.Div),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  geom_boxplot(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Greys") +
  geom_jitter(alpha=0.3)+
  scale_x_discrete(labels = c("Fortified \n (n=3)", "Necropolis \n (n = 10)", "Rural \n (n=14)", "Villa \n (n=11)", "Urban \n (n=24)" )) +
    scale_y_continuous(
    breaks = scales::pretty_breaks(n = 10)
  ) +
  theme(
    legend.position = "none",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.major.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.minor.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    )
  ) +
  labs(x = "Site type",
       y = "Site diversity",
       title = "LR - Shannon diversity")

plot_RichnessType.EMA <- ggplot(Df_Cond_Plants_RichnDiv.EMA, aes(x = Type, y = Specnumber, fill = Type)) +
    geom_hline(
    yintercept = mean(Df_Cond_Plants_RichnDiv.EMA$Specnumber),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  geom_boxplot(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Greys") +
  geom_jitter(alpha=0.3)+
  scale_x_discrete(labels = c("Fortified \n (n = 7)", "Necropolis \n (n = 1)", "Religious \n (n=2)", "Rural \n (n=18)", "Villa \n (n=11)", "Urban \n (n=25)" )) +
    scale_y_continuous(
    breaks = scales::pretty_breaks(n = 10)
  ) +
  theme(
    legend.position = "none",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.major.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.minor.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    )
  ) +
  labs(x = "Site type",
       y = "Number of species per site",
       title = "EMA - Plant richness")

plot_DiversityType.EMA <- ggplot(Df_Cond_Plants_RichnDiv.EMA, aes(x = Type, y = Shannon.Div, fill = Type)) +
    geom_hline(
    yintercept = mean(Df_Cond_Plants_RichnDiv.EMA$Shannon.Div),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  geom_boxplot(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Greys") +
  geom_jitter(alpha=0.3)+
  scale_x_discrete(labels = c("Fortified \n (n = 7)", "Necropolis \n (n = 1)", "Religious \n (n=2)", "Rural \n (n=18)", "Villa \n (n=11)", "Urban \n (n=25)" )) +
    scale_y_continuous(
    breaks = scales::pretty_breaks(n = 10)
  ) +
  theme(
    legend.position = "none",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.major.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.minor.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    )
  ) +
  labs(x = "Site type",
       y = "Site diversity",
       title = "EMA - Shannon Diversity")

plot_RichnessType.Ma <- ggplot(Df_Cond_Plants_RichnDiv.Ma, aes(x = Type, y = Specnumber, fill = Type)) +
  geom_hline(
    yintercept = mean(Df_Cond_Plants_RichnDiv.Ma$Specnumber),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  geom_boxplot(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Greys") +
  geom_jitter(alpha=0.3)+
  scale_x_discrete(labels = c("Fortified \n (n = 3)", "Religious \n (n=1)", "Rural \n (n=6)", "Urban \n (n=8)" )) +
    scale_y_continuous(
    breaks = scales::pretty_breaks(n = 10)
  ) +
  theme(
    legend.position = "none",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.major.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.minor.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    )
  ) +
  labs(x = "Site type",
       y = "Number of species per site",
       title = "Ma - Plant richness")

plot_DiversityType.Ma <- ggplot(Df_Cond_Plants_RichnDiv.Ma, aes(x = Type, y = Shannon.Div, fill = Type)) +
  geom_hline(
    yintercept = mean(Df_Cond_Plants_RichnDiv.Ma$Shannon.Div),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  geom_boxplot(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Greys") +
  geom_jitter(alpha=0.3)+
  scale_x_discrete(labels = c("Fortified \n (n = 3)", "Religious \n (n=1)", "Rural \n (n=6)", "Urban \n (n=8)" )) +
    scale_y_continuous(
    breaks = scales::pretty_breaks(n = 10)
  ) +
  theme(
    legend.position = "none",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.major.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.minor.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    )
  ) +
  labs(x = "Site type",
       y = "Site diversity",
       title = "Ma - Shannon Diversity")

```

```{r}
#| echo: false
#| eval: false

# Check mean of plant richness
# [RICHNESS] Urban Roman: 6.5 | Urban LR: 5.9 | Urban EMA: 7.2 | Urban Ma: 9
# [CORRECTED RICHNESS]: UrbR: 8.45 | UrbLR: 7.2 | UrbEMA: 9.625 | UrbMa: 17.5
# [DIVERSITY] Urban Roman: 1.02 | Urban LR: 1.20 | Urban EMA: 1.45 |Urban Ma: 1.39

mean((filter(Df_Cond_Plants_RichnDiv.R, Type=="Urban"))$Specnumber)
mean((filter(Df_Cond_Plants_RichnDiv.R[-IncompleteSamplesIndexes.R,], Type=="Urban"))$Specnumber)
mean((filter(Df_Cond_Plants_RichnDiv.LR, Type=="Urban"))$Specnumber)
mean((filter(Df_Cond_Plants_RichnDiv.LR[-IncompleteSamplesIndexes.LR,], Type=="Urban"))$Specnumber)
mean((filter(Df_Cond_Plants_RichnDiv.EMA, Type=="Urban"))$Shannon.Div)
mean((filter(Df_Cond_Plants_RichnDiv.EMA[-IncompleteSamplesIndexes.EMA,], Type=="Urban"))$Shannon.Div)
mean((filter(Df_Cond_Plants_RichnDiv.Ma, Type=="Urban"))$Specnumb)
mean((filter(Df_Cond_Plants_RichnDiv.Ma[-IncompleteSamplesIndexes.Ma,], Type=="Urban"))$Specnumber)


```

```{r}
#| echo: false
#| warning: false
#| layout: "[[100,100], [100,100]], [100,100]"
#| label: fig-type-richness-div
#| fig-cap: "Boxplots of plant richness and diversity in different site types. The grey dots (jitters) indicate the value for the single site, while the white boxplot shows the median and the quartile values." 
#| fig-subcap: 
#|   - "Roman plant richness" 
#|   - "Roman plant diversity."
#|   - "Late Roman plant richness" 
#|   - "Late Roman plant diversity."
#|   - "Early medieval plant richness" 
#|   - "Early medieval plant diversity."
#|   - "Medieval (11th c.) plant richness" 
#|   - "Medieval (11th c.) plant diversity."
#| fig-height: 4
#| fig-width: 6
#| fig-dpi: 600

plot_RichnessType.R
plot_DiversityType.R
plot_RichnessType.LR
plot_DiversityType.LR
plot_RichnessType.EMA
plot_DiversityType.EMA
plot_RichnessType.Ma
plot_DiversityType.Ma

```

#### Richness in urban contexts

The richness of plants in urban contexts has been calculated for every phase. As not every sample reported cereals, fruits/nuts and legumes, a correction has also been applied to exclude contexts that did not report the three types of plant taxa under examination. This correction has however strong disadvantages as it removes sites where the absence of certain plant categories may have been deliberate (*e.g.*, storages). However, if the figures vary considerably (especially in the case of the 11^th^ century CE which only consists of 2 samples after the correction), the general trend is similar after the correction. Plant richness in urban contexts slightly decreases after the Roman age, but early medieval cities are richer in plants when compared to the Roman and Late Roman phases. In the 11th century, plant richness increases further. These values will be discussed in the results chapter.

| Chronology | Richness | Samples | Richness\* | Samples\* |
|------------|----------|---------|------------|-----------|
| R          | 6.5      | 44      | 8.45       | 22        |
| LR         | 5.9      | 24      | 7.2        | 10        |
| EMA        | 7.2      | 25      | 9.6        | 8         |
| Ma         | 9        | 8       | 17.5       | 2         |

: Plant richness in urban contexts before and after (**\***) removing incomplete samples. {#tbl-richness-urban}

## Soil types vs Crops

see Rippon et al 2015, p. 81 as a comparison for results and Lodwick chapter in Hamerow and McKerracher 2022, p. 153

## Macroregion {style="text-align: justify;"}

### Cereals

#### Noble grains

The model for the diachronic probability of occurrence of plant taxa in the Italian macroregions follows the same strategy employed for the context type models. The chosen distribution is a Binomial where $F$ (short for 'found') on the left side of the formula is the outcome variable---a presence/absence indicator for the observation $i$. In the case of a single taxon, the value can either be 0 (for absence) or 1 (for presence) and the $T$ is 1, making the Binomial distribution effectively a Bernoulli distribution. If the model is for more than a single taxon, the $T$ is the total number of taxa that are being modelled. The model presented below is an intercept-only model, where the intercept $\alpha$ carries an interaction index ${[REGid]}$ as the model will provide estimates for each context type and chronology under examination.

$$
F_{i} \sim Binomial(T, \bar{p}_{i} )
$$

$$
logit(\bar{p}_{i}) = \alpha_{[REGid]}
$$

$$
\alpha_{[REGid]} \sim Normal(0,1.5)
$$

```{r}
#| echo: false

# Convert to list
Noble_Grains.list <- list(
    NG_Found = Noble_Grains_Reg$Grain_Count,
    MG_Tot = 2, # Barley + Common Wheat
    RC_ID = as.factor((interaction(Noble_Grains_Reg$Chronology, 
                                   Noble_Grains_Reg$Macroregion)))
   )
```

```{r}
#| echo: false
#| eval: false
#| code-fold: true


# Create a binomial model, where N is 2 because that is the total number of noble 
# grains studied in this research
m_ng_reg <- ulam(
    alist(
        NG_Found ~ dbinom( 2 , p ),
        logit(p) <- RegChr[RC_ID],
        RegChr[RC_ID] ~ dnorm(0,1.5)
    ), data=Noble_Grains.list , chains=4, log_lik = T
    )

saveRDS(m_ng_reg, "stan_models/m_ng_reg.rds")

```

```{r}
#| echo: false
#| warning: false
#| message: false
#| output: false


m_ng_reg <- readRDS("stan_models/m_ng_reg.rds")

m_ng_reg.df <- m_ng_reg %>%
  spread_draws(RegChr[RC_ID])

m_ng_reg.df %>% mutate(Region = case_when(
  RC_ID >= 9 &  RC_ID <=12 ~ "SI",
  RC_ID >= 1 & RC_ID <= 4 ~ "CI",
  RC_ID >= 5 & RC_ID <= 8  ~ "NI"
))  %>% mutate(Chrono = case_when(
    RC_ID == 4 |  RC_ID == 8 | RC_ID==12  ~ "R",
    RC_ID == 2 |  RC_ID == 6 | RC_ID == 10  ~ "LR",
    RC_ID == 1 |  RC_ID == 5 | RC_ID == 9  ~ "EMA",
    RC_ID == 3 |  RC_ID == 7 | RC_ID == 11 ~ "Ma"
)) -> m_ng_reg.df

m_ng_reg.plot <- ggplot(
  data = m_ng_reg.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(RegChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_ng_reg.df$RegChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(factor(Region, levels=c("SI", "CI", "NI")) ~ ., scales = "free") +
  labs(
    title = "Noble Grains",
    subtitle = "Macroregional distribution",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each macroregion and chronology.\nThe circle indicates the mean for each line."
  )

```

```{r}
#| echo: false
#| label: fig-bayes-glm-ng-macroregion
#| fig-cap: "Bayesian probability estimates for noble grains (common wheat and barley), divided by macroregion and chronology.\nThe prediction estimates are produced with a GLM and weakly informative priors. Credible intervals are provided."

m_ng_reg.plot
```

#### Minor grains

The model for minor grains in the Italian macroregion uses a Binomial distribution where $F$ (short for 'found') on the left side of the formula is the outcome variable---a presence/absence indicator for the observation $i$. As there are seven types of minor grains under investigation, the binomial will take 7 as maximum ($T$). This model effectively shows the probability of a single site to be reliant on minor grains. Emmer for instance, is ubiquitous in Italy, but in many cases it is the only minor grain found among other cereals in a context. Modelling the presence of more minor grains in a site can give insights on the rural economy. The model presented below is an intercept-only model, where the intercept $\alpha$ carries an interaction index ${[REGid]}$ as the model will provide estimates for each context type and chronology under examination.

$$
F_{i} \sim Binomial(7, \bar{p}_{i} )
$$

$$
logit(\bar{p}_{i}) = \alpha_{[REGid]}
$$

$$
\alpha_{[REGid]} \sim Normal(0,1.5)
$$

```{r}
#| echo: false
#| eval: true
#| code-fold: true

# Convert to list
Minor_Grains.list <- list(
    MG_Found = Minor_Grains$Grain_Count,
    MG_Tot = 7,
    RC_ID = as.factor((interaction(Minor_Grains$Chronology, 
                                   Minor_Grains$Macroregion)))
   )
```

```{r}
#| echo: false
#| eval: false
#| code-fold: true

# Create a binomial model, where N is 7 because that is the total number of minor 
# grains studied in this thesis
m_mg_reg <- ulam(
    alist(
        MG_Found ~ dbinom( 7 , p ),
        logit(p) <- RegChr[RC_ID],
        RegChr[RC_ID] ~ dnorm(0,1.5)
    ), data=Minor_Grains.list , chains=4
    )

saveRDS(m_mg_reg, "stan_models/m_mg_reg.rds")

```

```{r}
#| echo: false
#| warning: false
#| message: false
#| output: false

m_mg_reg <- readRDS("stan_models/m_mg_reg.rds")

m_mg_reg.df <- m_mg_reg %>%
  spread_draws(RegChr[RC_ID])

m_mg_reg.df %>% mutate(Region = case_when(
  RC_ID >= 9 &  RC_ID <=12 ~ "SI",
  RC_ID >= 1 & RC_ID <= 4 ~ "CI",
  RC_ID >= 5 & RC_ID <= 8  ~ "NI"
))  %>% mutate(Chrono = case_when(
    RC_ID == 4 |  RC_ID == 8 | RC_ID==12  ~ "R",
    RC_ID == 2 |  RC_ID == 6 | RC_ID == 10  ~ "LR",
    RC_ID == 1 |  RC_ID == 5 | RC_ID == 9  ~ "EMA",
    RC_ID == 3 |  RC_ID == 7 | RC_ID == 11 ~ "Ma"
)) -> m_mg_reg.df

m_mg_reg.plot <- ggplot(
  data = m_mg_reg.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(RegChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_mg_reg.df$RegChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(factor(Region, levels=c("SI", "CI", "NI")) ~ ., scales = "free") +
  labs(
    title = "Minor Grains",
    subtitle = "Macroregional distribution",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each macroregion and chronology.\nThe circle indicates the mean for each line."
  )

```

```{r}
#| echo: false
#| label: fig-bayes-glm-mg-macroregion
#| fig-cap: "Bayesian probability estimates for minor grains (Emmer, Einkorn, Foxtail and Broomcorn millets, Sorghum), divided by macroregion and chronology.\nThe prediction estimates are produced with a GLM and weakly informative priors. Credible intervals are provided."

m_mg_reg.plot
```

#### Richness and diversity {#sec-richness-diversity-macroregions style="text-align:justify;"}

::: callout-important
## Section in progress {style="text-align:justify;"}
:::

::: {.content-visible when-format="html"}
```{r}
#| echo: false
#| output: false
#| code-summary: "Show the code: data preparation"
#| code-overflow: wrap

# Species richness based on geographical features
# RELATIVE PROPORTIONS OF ARCHAEOBOT_VIZ QUERY EXPORT FROM THE DB
# (Condensed, without totals)


# Add more info to the dataframe
Df_Cond_Plants_Rel_Richness_Diversity <- data.frame(
                                 "Geo" = Df_Cond_Plants$Geo,
                                 "Chronology" = Df_Cond_Plants$Chronology, 
                                 "Type"= Df_Cond_Plants$Type, 
                                 "Specnumber" = specnumber(Df_Cond_Plants_Rel),
                                 "Shannon Div" = diversity(Df_Cond_Plants_Rel),
                                 Df_Cond_Plants_Rel
)

Df_Cond_Plants_Rel_withMacroregion <- data.frame("Geo" = Df_Cond_Plants$Geo,
                                                 "Chronology" = Df_Cond_Plants$Chronology,
                                                 "Type"= Df_Cond_Plants$Type, 
                                                 "Macroregion" = Df_Cond_Plants$name_macroreg,
                                                 "Specnumber" = specnumber(Df_Cond_Plants_Rel[1:10]), #Only cereals
                                                 "Shannon Div" = diversity(Df_Cond_Plants_Rel[1:10]),
                                                 Df_Cond_Plants_Rel[1:10]
)

# Let's plot the diversity by macroregion

# Creating the dataframes for R and EMA age 
# I know it's called "Plants" but it's actually just cereals
Df_Cond_Plants_Rel_withMacroregion.R <- filter(Df_Cond_Plants_Rel_withMacroregion, Chronology == "R")
Df_Cond_Plants_Rel_withMacroregion.LR <- filter(Df_Cond_Plants_Rel_withMacroregion, Chronology == "LR")
Df_Cond_Plants_Rel_withMacroregion.EMA <- filter(Df_Cond_Plants_Rel_withMacroregion, Chronology == "EMA")

```

```{r}
#| echo: false
#| output: false
#| code-summary: "Show the code: plots"
#| code-overflow: wrap

pal_RichnessvsGeo <- c("cadetblue3", "gold1",  "bisque4", "palegreen4")

plot_RichnessMacroReg.R <- ggplot(Df_Cond_Plants_Rel_withMacroregion.R, aes(x = Macroregion, y = Specnumber, fill = Macroregion)) +
    geom_hline(
    yintercept = mean(Df_Cond_Plants_Rel_withMacroregion.R$Specnumber),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  geom_boxplot(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Greys") +
  geom_jitter(alpha=0.3)+
  scale_x_discrete(labels = c("Central Italy \n (n = 5)", "Northern Italy \n (n = 41)", "Southern Italy \n (n=34)")) +
  scale_y_continuous(
    breaks = scales::pretty_breaks(n = 10)
  ) +
  theme(
    legend.position = "none",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.major.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.minor.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    )
  ) +
  labs(x = "Macroregion",
       y = "Number of species per site",
       title = "R - Cereal richness")

plot_RichnessMacroReg.EMA <- ggplot(Df_Cond_Plants_Rel_withMacroregion.EMA, aes(x = Macroregion, y = Specnumber, fill = Macroregion)) +
    geom_hline(
    yintercept = mean(Df_Cond_Plants_Rel_withMacroregion.EMA$Specnumber),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  geom_boxplot(width = 0.2, alpha = 0.6) +
  scale_fill_brewer(palette = "Greys") +
  geom_jitter(alpha=0.3)+
  scale_x_discrete(labels = c("Central Italy \n (n = 11)", "Northern Italy \n (n = 36)", "Southern Italy \n (n=17)")) +
    scale_y_continuous(
    breaks = scales::pretty_breaks(n = 10)
  ) +
  theme(
    legend.position = "none",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.major.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    ),
    panel.grid.minor.y = element_line(
      color = "grey50",
      linewidth = 0.05,
      linetype = 2
    )
  ) +
  labs(x = "Macroregion",
       y = "Number of species per site",
       title = "EMA - Cereal richness")

# Check median of cereal richness per macroregion

# ROMAN NORTH
mean((filter(Df_Cond_Plants_Rel_withMacroregion.R, Macroregion=="Northern Italy"))$Specnumber)
#ROMAN SOUTH
mean((filter(Df_Cond_Plants_Rel_withMacroregion.R, Macroregion=="Southern Italy"))$Specnumber)
# EMA NORTH
mean((filter(Df_Cond_Plants_Rel_withMacroregion.EMA, Macroregion=="Northern Italy"))$Specnumber)
#EMA SOUTH
mean((filter(Df_Cond_Plants_Rel_withMacroregion.EMA, Macroregion=="Southern Italy"))$Specnumber)

```
:::

Cereals share similar presence values in Roman Northern and Southern Italian sites (@fig-cereal-richness-RvsEMA). Central Italy reports higher values, although this is based only on three sites and hence it is not reliable. During the Early Middle Ages, Central Italy again is the richest in cereals, closely followed by Northern Italy. Interestingly, Southern Italy still reports values very close to the Roman age. A full list of the Southern Italian EMA sites is reported in @tbl-southern-ema-sites.

```{r}
#| echo: false
#| layout: "[[100,100], [1]]"
#| label: fig-cereal-richness-RvsEMA
#| fig-cap: "Boxplots of cereal richness in the Italian macroregions. The grey dots (jitters) indicate the value for the single site, while the white boxplot shows the median and the quartile values." 
#| fig-subcap: 
#|   - "Roman age." 
#|   - "Early Medieval age."
#| fig-height: 4
#| fig-width: 6
#| fig-dpi: 600

plot_RichnessMacroReg.R
plot_RichnessMacroReg.EMA

```

| ID  | Site                                   | Region     | Geography    | Type         | Culture/Influence |
|-----|----------------------------------------|------------|--------------|--------------|-------------------|
| 98  | S. Maria in Cività, D85                | Molise     | Hilltop      | Urban        | Lombard           |
| 107 | S. Giovanni di Ruoti, Phase 3A         | Basilicata | Mountain     | Monastery    | Lombard           |
| 107 | S. Giovanni di Ruoti, Phase 3B         | Basilicata | Mountain     | Monastery    | Lombard           |
| 198 | Salapia, area botteghe, US 2475        | Puglia     | Coast/Lagoon | Urban        | Lombard           |
| 198 | Salapia, area botteghe, US 2437        | Puglia     | Coast/Lagoon | Urban        | Lombard           |
| 199 | Salapia, area conceria, US 2054        | Puglia     | Coast/Lagoon | Urban        | Lombard           |
| 199 | Salapia, area conceria, US 2211-2217   | Puglia     | Coast/Lagoon | Urban        | Lombard           |
| 199 | Salapia, area conceria, 8th-9th c.     | Puglia     | Coast/Lagoon | Urban        | Lombard           |
| 196 | Faragola, wastepit 61                  | Puglia     | Plain        | Rural, villa | Lombard           |
| 196 | Faragola, wastepit 66                  | Puglia     | Plain        | Rural, villa | Lombard           |
| 234 | Colle Castellano, Phase 3-4            | Molise     | Hill         | Urban        | Lombard           |
| 177 | San Vincenzo al Volturno, kitchen area | Molise     | Hill         | Monastery    | Lombard           |
| 101 | Supersano, loc. Scorpo                 | Puglia     | Plain        | Rural        | Byzantine         |
| 250 | Apigliano, 9th-10th c., pits           | Puglia     | Plain        | Rural        | Byzantine         |
| 250 | Apigliano, 10th-11th c., pits          | Puglia     | Plain        | Rural        | Byzantine         |
| 196 | Faragola, granary A7                   | Puglia     | Plain        | Rural, villa | Lombard           |
| 196 | Faragola, granary A8                   | Puglia     | Plain        | Rural, villa | Lombard           |

: List of Southern Italian sites with chronology EMA {#tbl-southern-ema-sites}

#### Assessing the difference {#sec-permanova-cereals}

::: callout-note
## Notes on terminology: PERMANOVA {style="text-align:justify;"}

Permutational multivariate analysis of variance (PERMANOVA) is a non-parametric multivariate statistical test used to compare group of objects. By using measure space, the null hypothesis that the centroids and dispersion of groups are identical is tested. The null hypothesis is rejected if either the centroid or the spread of the objects differs between the groups. A prior calculation of the distance between any two objects included in the experiment is used to determine whether the test is valid or not[^archaeobotany-2] [@andersonPermutationalMultivariateAnalysis2017]. In this context, the *null hypothesis* is that there is no regional difference in the cereals dataset, with cereals being evenly distributed across macroregions and chronologies.
:::

[^archaeobotany-2]: Source: Wikipedia. Change the source later

The suggestion of an Early Medieval shift in cereal farming stated in @sec-macroregional-differences-ubiquity and @sec-richness-diversity-macroregions needs statistical support. Considering that data is not unimodal and that we are dealing with presence/absence analysis, the best choice is to use a non-parametric test as PERMANOVA on the early medieval botanical dataset. Prior to performing the test, it was necessary to pre-process data by:

-   Selecting all the cereals columns of the plant remains table, keeping the categorical variables: `Macroregion`.

-   Removing empty rows (samples that only reported seeds/fruits, but not cereals).

-   Transforming the raw counts into presence/absence, using the function `decostand()` (`method=pa`) in the `R` package `vegan` [@vegan].

::: {.content-visible when-format="html"}
```{r}
#| code-fold: true
#| output: false
#| code-summary: "Show the code: Pre-processing"
#| code-overflow: wrap
# Testing the results: Regionality in the dataset? 

# Load libraries and set seed
library(vegan)
set.seed(29)

# Pre processing: remove empty rows
# Note: The input table is the CONDENSED table without totals

# Selecting all the cereals columns of the plant remains table, keeping some categorical variables 
cer_macroreg_ubiquity_transp.tot <- Df_Cond_Plants[c(4,5,6,7,11:19)]

# Set NAs to 0
cer_macroreg_ubiquity_transp.tot[is.na(cer_macroreg_ubiquity_transp.tot)]<- 0

# Selecting all rows with data (since we selected only with cereals, and some sites only had fruits/pulses we might have empty rows)
cer_macroreg_ubiquity_transp.tot <- cer_macroreg_ubiquity_transp.tot[rowSums(cer_macroreg_ubiquity_transp.tot[5:13])>0,]

# Assigning a column name "Macroregion"
colnames(cer_macroreg_ubiquity_transp.tot)[1] = "Macroregion"

# SUBSETTING DATA

# ROMAN
# Selecting the Chronology of interest (R) and excluding Central Italy
cer_macroreg_ubiquity_transp.tot.Roman <- subset(cer_macroreg_ubiquity_transp.tot, Macroregion!="Central Italy" & Chronology=="R")

# Creating two dataframes for categorical and numerical columns (Roman)
cer_macroreg_ubiquity_transp.categ.Roman <- cer_macroreg_ubiquity_transp.tot.Roman[1:4]
cer_macroreg_ubiquity_transp.data.Roman <- cer_macroreg_ubiquity_transp.tot.Roman[5:13]

# Converting the numerical columns into a presence/absence matrix (using method=pa)
cer_macroreg_ubiquity_transp.dist.Roman <- decostand(cer_macroreg_ubiquity_transp.data.Roman, method="pa", na.rm=TRUE)
cer_macroreg_ubiquity_transp.dist.Roman <- decostand(cer_macroreg_ubiquity_transp.data.Roman, method="pa", na.rm=TRUE)


## EMA
cer_macroreg_ubiquity_transp.tot<- subset(cer_macroreg_ubiquity_transp.tot, Macroregion!="Central Italy" & Chronology=="EMA")

# Creating two dataframes for categorical and numerical columns (EMA)
cer_macroreg_ubiquity_transp.categ <- cer_macroreg_ubiquity_transp.tot[1:4]
cer_macroreg_ubiquity_transp.data <- cer_macroreg_ubiquity_transp.tot[5:13]

# Converting the numerical columns into a presence/absence matrix (using method=pa)
# Roman
cer_macroreg_ubiquity_transp.dist.Roman <- decostand(cer_macroreg_ubiquity_transp.data.Roman, method="pa", na.rm=TRUE)
# EMA
cer_macroreg_ubiquity_transp.dist <- decostand(cer_macroreg_ubiquity_transp.data, method="pa", na.rm=TRUE)



```
:::

After the pre-processing, it was possible to run the PERMANOVA using the function `adonis2()` in the package `vegan`. The function creates a distance matrix and computes an analysis of variance on the matrix. The method chosen to calculate the distance matrix is the `jaccard` distance. The Jaccard distance, based on the Jaccard similarity index, is a value of dissimilarity between sample sets [@kosubNoteTriangleInequality2019]. When compared to other dissimilarity indices, it is more appropriate for presence/absence analyses as it is not based on Euclidean distance.

**Results of `adonis2()`**.

::: {.content-visible when-format="html"}
```{r}
#| code-fold: true
#| output: false
#| code-summary: "Show the code: adonis2() "
#| code-overflow: wrap

cer_macroreg_ubiquity_transp.div <- adonis2(
  cer_macroreg_ubiquity_transp.dist ~ Macroregion, 
  data = cer_macroreg_ubiquity_transp.categ,
  permutations = 10000, method="jaccard"
  )

cer_macroreg_ubiquity_transp.div.Roman <- adonis2(
  cer_macroreg_ubiquity_transp.dist.Roman ~ Macroregion, 
  data = cer_macroreg_ubiquity_transp.categ.Roman,
  permutations = 10000, method="jaccard"
  )

```
:::

*Roman*

```{r}
#| echo: false
cer_macroreg_ubiquity_transp.div.Roman
```

*Early Medieval*

```{r}
#| echo: false
cer_macroreg_ubiquity_transp.div

```

The calculation of PERMANOVA on the Roman dataset using the variable `Macroregion` reported a not statistically significant p-value, suggesting a degree of homogeneity. On the other hand, when applied to the early Medieval dataset, the results were highly significant (0\<p\<0.001) with a 99.99% confidence. PERMANOVA has not been calculated on the Late Roman dataset as samples from Southern Italy were too scarce. To confirm the significance of the results of PERMANOVA applied to the EMA dataset, it is necessary to check that its assumptions are met (especially since we are dealing with small groups of data). Firstly, we check the homogeneity of variances. The function `betadisper()` from the package `vegan` provides the distances of group samples from centroids. If the variation is even, the null hypothesis of no difference in dispersion between groups is accepted. To test the variation, it is possible to use the analysis of variance (ANOVA).

::: {.content-visible when-format="html"}
```{r}
#| code-fold: true
#| output: false
#| code-summary: "Show the code: betadisper()"
#| code-overflow: wrap

# We do not need to calculate the distance separately, but it will be useful later for the betadisper() function

# Distance dissimilarity matrix with the Jaccard method
cer_macroreg_ubiquity_transp.dist2 <- vegdist(cer_macroreg_ubiquity_transp.dist, method="jaccard", na.rm=TRUE)

# Betadisper: distances of group samples from centroids
cer_macroreg_ubiquity_transp.betadisper <- betadisper(cer_macroreg_ubiquity_transp.dist2, cer_macroreg_ubiquity_transp.categ$Macroregion)
```
:::

**Results of `anova()` on the betadisper.**

```{r}
#| code-fold: true
#| output: true
#| code-summary: "Show the code: ANOVA on betadisper()"
#| code-overflow: wrap

# We will see that the ANOVA's p-value is not significant meaning that group dispersions are homogenous 
#("Null hypothesis of no difference in dispersion between groups"; https://www.rdocumentation.org/packages/vegan/versions/2.4-2/topics/betadisper).

anova(cer_macroreg_ubiquity_transp.betadisper) # This should not be significant!
```

```{r}
#| echo: false
#| layout: "[[100,100], [1]]"
#| label: fig-betadisper
#| fig-cap: "Results of the betadisper() (groups dispersions) on the distance matrix calculated with the Jaccard method." 
#| fig-subcap: 
#|   - "Groups dispersions plot with confidence ellipses." 
#|   - "Boxplot showing equal distances from centroid."
#| fig-height: 4
#| fig-width: 5
#| fid-dpi: 300

# Now we can plot and see that group dispersions (distances from centroids) are very similar, but compositions seem to be very different. Let's go to adonis to test that.
plot(cer_macroreg_ubiquity_transp.betadisper, hull=FALSE, ellipse=TRUE, main="Betadisper plot", col=c("#90a955", "#212529"))

boxplot(cer_macroreg_ubiquity_transp.betadisper, col="khaki4", xlab="Macroregion")

```

The `betadisper()` graphs (@fig-betadisper) show similar distances from the centroids for the categories `Northern Italy` and `Southern Italy`. In addition, the ANOVA on the `betadisper()` shows that the separation is not significant (p-value over the significance threshold), meaning that the groups dispersions are homogeneous. We can thus be confident in the PERMANOVA results and accept the difference between the two groups of sites under investigation. In other words, the Southern and Northern Italian group of sites are different during the Early Middle Ages for what concerns cereal farming.

Running the same tests on the Roman sites failed to separate the two groups of sites, confirming that there was not a significant difference in the types of cereals cultivated during the Roman age between Northern and Southern Italy.

#### Quantifying the separation: nMDS {#sec-nMDS-Cereals style="text-align:justify"}

::: callout-note
## Notes on terminology: Wasserstein metric {style="text-align:justify;"}

The [Wasserstein distance](https://en.wikipedia.org/wiki/Earth_mover%27s_distance) (or earth's mover distance) is a measure of distance between two probability distributions on a metric space.
:::

In addition to statistically testing the separation between the Northern and Southern Italian early medieval cereals dataset (@sec-permanova-cereals), it is possible to measure the distance between groups of sites both in the Roman and early Middle ages. For this task, a dimensionality reduction algorithm has been chosen: the *non-metric multidimensional scaling*, from the `R` library `vegan`. A more in-depth explanation of the algorithm can be read in @sec-met-nmds. To avoid fallacy in computations, the macroregion `Central Italy` and the chronologies `LR` (Late Roman) and `Ma` (11^th^ c. onwards) have been excluded from this test---the uneven distribution of the group of samples required a cautious approach. The nMDS has been run with a reduction to only one dimension, using KDE plots to visualize the results. Setting the dimension to one allows easier calculations of distance. In @fig-nMDS-1D-macroregion (a), it is possible to see the nMDS performed on the Roman cereals presence/absence dataset. As already pointed out, the PERMANOVA did not produce significant results for this dataset and the Wasserstein distance (calculated with the `wasserstein1d()` function in the `transport` library) is indeed shorter for the Roman dataset. For both chronologies there is an overlap in the curves, which is more considerable in the Roman age (indicating that the group of samples are more similar). The overlap for the EMA groups (@fig-nMDS-1D-macroregion, b) is probably due to the fact that the presence of the noble grains is not by itself a 'marker' of Southern Italian sites---these grains are also very common in the North. The difference is that in the South noble grains are not cultivated in conjunction with other grains. The graph for the EMA chronology shows a clearer separation of the macroregional groups, with some minor overlaps. Moreover, the graph also displays variability in the Northern Italian dataset. The variability can also be assessed from the outliers in the boxplots in @fig-boxplot-nMDS-R-EMA.

::: {.content-visible when-format="html"}
**Source code:**

```{r}
#| code-summary: "Show the code: Data preparation"
#| code-overflow: wrap
#| code-fold: true

# DATA PREPARATION #

# Creating a simple dataframe just for the purpose of the NCA
Df_Cond_Plants_simplified <- data.frame(
  "Chronology" = Df_Cond_Plants$Chronology, 
  "Type" = Df_Cond_Plants$Type,
  "Macroregion" = Df_Cond_Plants$name_macroreg,
  "Weight" = Df_Cond_Plants$weight,
  Df_Cond_Plants[11:ncol(Df_Cond_Plants)]
  )

# Joining site typology categories to simplify the output, using library stringr
library(vegan)
library(stringr)

Df_Cond_Plants_simplified$Type <- str_replace_all(
  Df_Cond_Plants_simplified$Type, c(
    "Rural site, villa" = "Rural", 
    "Rural site, mansio" = "Rural",
    "Religious, monastery" = "Religious",
    "Castle" = "Fortified",
    "Castrum" = "Fortified")
  )

# Convert to Presence (1) / Absence (0) using library vegan
Df_Cond_Plants_simplified[5:ncol(Df_Cond_Plants_simplified)] <- decostand(Df_Cond_Plants_simplified[5:ncol(Df_Cond_Plants_simplified)], method="pa")

# Creating dataframes for the chronologies R and EMA
Df_Cereals_R <- subset(Df_Cond_Plants_simplified, Chronology=="R" & Macroregion!="Central Italy")
Df_Cereals_EMA <- subset(Df_Cond_Plants_simplified, Chronology=="EMA" & Macroregion!="Central Italy")

# Selecting only cereals from both dataframes
Df_Cereals_R <- Df_Cereals_R[1:14]
Df_Cereals_R[is.na(Df_Cereals_R)] <- 0
Df_Cereals_R <- Df_Cereals_R[rowSums(Df_Cereals_R[,5:14] != 0) > 0, ] # Removing empty rows

Df_Cereals_EMA <- Df_Cereals_EMA[1:14]
Df_Cereals_EMA[is.na(Df_Cereals_EMA)] <- 0
Df_Cereals_EMA <- Df_Cereals_EMA[rowSums(Df_Cereals_EMA[,5:14] != 0) > 0, ]

```

```{r}
#| echo: false
#| output: false

library(ggpubr)
set.seed(7)

# Perform the metaMDS to 1D for Df_Cereals_R and Df_Cereals_EMA 
mds_R <- metaMDS(Df_Cereals_R[, c(5:14)], k=1, distance = "jaccard")
mds_EMA <- metaMDS(Df_Cereals_EMA[, c(5:14)], k=1, distance = "jaccard")

# Add the Macroregion data to the metaMDS results for both dataframes
mds_df_R <- data.frame(mds_R$points, Macroregion = Df_Cereals_R$Macroregion)
mds_df_EMA <- data.frame(mds_EMA$points, Macroregion = Df_Cereals_EMA$Macroregion)

# Create dataframes to calculate wasserstein distance
library(transport)

MDS_Scores_R_SI <- (subset(mds_df_R, Macroregion=="Southern Italy"))$MDS1
MDS_Scores_R_NI <- (subset(mds_df_R, Macroregion=="Northern Italy"))$MDS1

MDS_Scores_EMA_SI <- (subset(mds_df_EMA, Macroregion=="Southern Italy"))$MDS1
MDS_Scores_EMA_NI <- (subset(mds_df_EMA, Macroregion=="Northern Italy"))$MDS1

       
# Create the plots
mds_R.plot <- ggplot(
  data=mds_df_R, 
  aes(x=MDS1, 
      group=Macroregion, 
      color=Macroregion, 
      fill=Macroregion)) +
    geom_density(adjust=1.5, alpha=.2) +
      geom_vline(aes(xintercept=mean(MDS_Scores_R_SI)),
            color="#90a955", linetype="dashed", linewidth=.8)+ #South
      geom_vline(aes(xintercept=mean(MDS_Scores_R_NI)),
            color="#212529", linetype="dashed", linewidth=.8)+ #North
  scale_fill_manual(values=c("#212529","#90a955"))+
  scale_color_manual(values=c("#212529","#90a955"))+
  theme_pubclean()+
  theme(legend.position = "none")+
    labs(
      title="Roman age",
      caption = paste0(
      "PERMANOVA: p > 0.05 \n",
      "Wasserstein distance: ", round(
      wasserstein1d(MDS_Scores_R_SI,MDS_Scores_R_NI),2
      )))

mds_EMA.plot <- ggplot(
  data=mds_df_EMA, 
  aes(x=MDS1, group=Macroregion, color=Macroregion, fill=Macroregion)
  ) +
  scale_alpha(guide = 'none')+
  geom_density(adjust=1.5, alpha=.2) +
  geom_vline(
    aes(xintercept=mean(MDS_Scores_EMA_SI), color="mean"),
    color="#90a955", linetype="dashed", linewidth=.8)+ #South
  geom_vline(
    aes(xintercept=mean(MDS_Scores_EMA_NI)),
    color="#212529", linetype="dashed", linewidth=.8)+ #North
  scale_fill_manual(values=c("#212529","#90a955"))+
  scale_color_manual(values=c("#212529","#90a955"))+
  theme_pubclean()+
    labs(
      title="EMA",
      caption = paste0(
      "PERMANOVA: p < 0.0001 \n",
      "Wasserstein distance: ", round(
      wasserstein1d(MDS_Scores_EMA_SI,MDS_Scores_EMA_NI),2
      )))+
  theme(legend.position = "right")


mds_R.boxplot <- ggplot(mds_df_R, aes(x=Macroregion, y=MDS1, fill=Macroregion)) + 
    geom_boxplot(alpha=.2)+
  scale_fill_manual(values=c("#212529","#90a955"))+
  scale_color_manual(values=c("#212529","#90a955"))+
  theme_pubclean()+
    labs(
      title="Roman Age")+
  theme(legend.position = "none")

mds_EMA.boxplot <- ggplot(mds_df_EMA, aes(x=Macroregion, y=MDS1, fill=Macroregion)) + 
    geom_boxplot(alpha=.2)+
  scale_fill_manual(values=c("#212529","#90a955"))+
  scale_color_manual(values=c("#212529","#90a955"))+
  theme_pubclean()+
    labs(
      title="EMA")+
  theme(legend.position = "right")

```

```{r}
#| label: fig-nMDS-1D-macroregion
#| fig-cap: "nMDS reduction to one dimension performed on the Roman and early Medieval cereal datasets. The dashed colored lines indicate the mean of the distribution."
#| fig-subcap: 
#|  - "Roman age."
#|  - "Early Medieval Age."
#| layout-nrow: 1
#| layout-ncol: 2
#| echo: false


# Plot the two plots side by side
mds_R.plot 
mds_EMA.plot
```

```{r}
#| echo: false
#| label: fig-boxplot-nMDS-R-EMA
#| fig-cap: "Boxplots showing the nMDS scores for Northern and Southern Roman Italy."
#| fig-subcap: 
#|  - "Roman age."
#|  - "Early Medieval age."
#| layout-nrow: 1
#| layout-ncol: 2

mds_R.boxplot
mds_EMA.boxplot

```

```{r}
#| echo: false
#| label: fig-stressplots-nMDS-R-EMA
#| fig-cap: "Shepards stressplots showing the goodness of fit between ordination distances and observed dissimilarities for both Chronologies."
#| fig-subcap: 
#|  - "Roman age."
#|  - "Early Medieval age."
#| layout-nrow: 1
#| layout-ncol: 2

stressplot(mds_R, p.col="khaki4", l.col="#212529")

stressplot(mds_EMA, p.col="khaki4", l.col="#212529")

```
:::

### Legumes

```{r}
#| echo: false

####################
## LEGUMES 
####################

# Convert to list
Legumes_reg.list <- list(
    Leg_Found = Legumes$Seed_Count,
    Leg_Tot = 7,
    RC_ID = as.factor((interaction(Legumes$Chronology, 
                                   Legumes$Macroregion)))
   )

Legumes_reg.list$RC_ID <- droplevels(Legumes_reg.list$RC_ID)

```

```{r}
#| echo: false
#| eval: false
#| code-fold: true

# Create a binomial model, where N is 7 because that is the total number of minor 
# grains studied in this thesis
m_leg_reg <- ulam(
    alist(
        Leg_Found ~ dbinom( 7 , p ),
        logit(p) <- RegChr[RC_ID],
        RegChr[RC_ID] ~ dnorm(0,1.5)
    ), data=Legumes_reg.list , chains=4
    )

saveRDS(m_leg_reg, "stan_models/m_leg_reg.rds")

```

```{r}
#| echo: false
#| warning: false
#| message: false
#| output: false

m_leg_reg <- readRDS("stan_models/m_leg_reg.rds")

m_leg_reg.df <- m_leg_reg %>%
  spread_draws(RegChr[RC_ID])

m_leg_reg.df %>% mutate(Region = case_when(
  RC_ID >= 9 &  RC_ID <=12 ~ "SI",
  RC_ID >= 1 & RC_ID <= 4 ~ "CI",
  RC_ID >= 5 & RC_ID <= 8  ~ "NI"
))  %>% mutate(Chrono = case_when(
    RC_ID == 4 |  RC_ID == 8 | RC_ID==12  ~ "R",
    RC_ID == 2 |  RC_ID == 6 | RC_ID == 10  ~ "LR",
    RC_ID == 1 |  RC_ID == 5 | RC_ID == 9  ~ "EMA",
    RC_ID == 3 |  RC_ID == 7 | RC_ID == 11 ~ "Ma"
)) -> m_leg_reg.df

m_leg_reg.plot <- ggplot(
  data = m_leg_reg.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(RegChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_leg_reg.df$RegChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(factor(Region, levels=c("SI", "CI", "NI")) ~ ., scales = "free") +
  labs(
    title = "Legumes",
    subtitle = "Macroregional distribution",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each macroregion and chronology.\nThe circle indicates the mean for each line."
  )

```

```{r}
#| echo: false
#| label: fig-bayes-glm-legumes-macroregion
#| fig-cap: "Bayesian probability estimates for legumes, divided by macroregion and chronology.\nThe prediction estimates are produced with a GLM and weakly informative priors. Credible intervals are provided."

m_leg_reg.plot

```

### Fruits

#### Grape

```{r}
#| echo: false

Grape_reg.list <- list(
    Grape_Found = Grape$Present,
    RC_ID = as.factor((interaction(Legumes$Chronology, 
                                   Legumes$Macroregion)))
   )

Grape_reg.list$RC_ID <- droplevels(Grape_reg.list$RC_ID)
```

```{r}
#| echo: false
#| eval: false

m_grape_reg <- ulam(
    alist(
        Grape_Found ~ dbinom( 1 , p ),
        logit(p) <- RegChr[RC_ID],
        RegChr[RC_ID] ~ dnorm(0,1.5)
    ), data=Grape_reg.list , chains=4
    )

saveRDS(m_grape_reg, "stan_models/m_grape_reg.rds")


```

```{r}
#| echo: false
#| warning: false
#| message: false
#| output: false

m_grape_reg <- readRDS("stan_models/m_grape_reg.rds")

m_grape_reg.df <- m_grape_reg %>%
  spread_draws(RegChr[RC_ID])

m_grape_reg.df %>% mutate(Region = case_when(
  RC_ID >= 9 &  RC_ID <=12 ~ "SI",
  RC_ID >= 1 & RC_ID <= 4 ~ "CI",
  RC_ID >= 5 & RC_ID <= 8  ~ "NI"
))  %>% mutate(Chrono = case_when(
    RC_ID == 4 |  RC_ID == 8 | RC_ID==12  ~ "R",
    RC_ID == 2 |  RC_ID == 6 | RC_ID == 10  ~ "LR",
    RC_ID == 1 |  RC_ID == 5 | RC_ID == 9  ~ "EMA",
    RC_ID == 3 |  RC_ID == 7 | RC_ID == 11 ~ "Ma"
)) -> m_grape_reg.df

m_grape_reg.plot <- ggplot(
  data = m_grape_reg.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(RegChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_grape_reg.df$RegChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(factor(Region, levels=c("SI", "CI", "NI")) ~ ., scales = "free") +
  labs(
    title = "Grape",
    subtitle = "Macroregional distribution",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each macroregion and chronology.\nThe circle indicates the mean for each line."
  )

```

```{r}
#| echo: false
#| label: fig-bayes-glm-grape-macroregion
#| fig-cap: "Bayesian probability estimates for grape, divided by macroregion and chronology.\nThe prediction estimates are produced with a GLM and weakly informative priors. Credible intervals are provided."

m_grape_reg.plot

```

#### Olives

```{r}
#| echo: false


# Convert to list
Olive_reg.list <- list(
    Olive_Found = Olives$Present,
    RC_ID = as.factor((interaction(Olives$Chronology, 
                                   Olives$Macroregion)))
   )

Olive_reg.list$RC_ID <- droplevels(Olive_reg.list$RC_ID)
  
```

```{r}
#| echo: false
#| eval: false

m_olive_reg <- ulam(
    alist(
        Olive_Found ~ dbinom( 1 , p ),
        logit(p) <- RegChr[RC_ID],
        RegChr[RC_ID] ~ dnorm(0,1.5)
    ), data=Olive_reg.list , chains=4
    )

saveRDS(m_olive_reg, "stan_models/m_olive_reg.rds")

```

```{r}
#| echo: false
#| warning: false
#| message: false
#| output: false

m_olive_reg <- readRDS("stan_models/m_olive_reg.rds")

m_olive_reg.df <- m_olive_reg %>%
  spread_draws(RegChr[RC_ID])

m_olive_reg.df %>% mutate(Region = case_when(
  RC_ID >= 9 &  RC_ID <=12 ~ "SI",
  RC_ID >= 1 & RC_ID <= 4 ~ "CI",
  RC_ID >= 5 & RC_ID <= 8  ~ "NI"
))  %>% mutate(Chrono = case_when(
    RC_ID == 4 |  RC_ID == 8 | RC_ID==12  ~ "R",
    RC_ID == 2 |  RC_ID == 6 | RC_ID == 10  ~ "LR",
    RC_ID == 1 |  RC_ID == 5 | RC_ID == 9  ~ "EMA",
    RC_ID == 3 |  RC_ID == 7 | RC_ID == 11 ~ "Ma"
)) -> m_olive_reg.df

m_olive_reg.plot <- ggplot(
  data = m_olive_reg.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(RegChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_olive_reg.df$RegChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(factor(Region, levels=c("SI", "CI", "NI")) ~ ., scales = "free") +
  labs(
    title = "Olive",
    subtitle = "Macroregional distribution",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each macroregion and chronology.\nThe circle indicates the mean for each line."
  )

```

```{r}
#| echo: false
#| label: fig-bayes-glm-olive-macroregion
#| fig-cap: "Bayesian probability estimates for olive, divided by macroregion and chronology.\nThe prediction estimates are produced with a GLM and weakly informative priors. Credible intervals are provided."

m_olive_reg.plot

```

#### Nuts

```{r}
#| echo: false

####################
## NUTS
####################

# Convert to list
Nuts_reg.list <- list(
    Nuts_Found = Nuts$Seed_Count,
    Nuts_Tot = 3,
    RC_ID = as.factor((interaction(Nuts$Chronology, 
                                   Nuts$Macroregion)))
   )

Nuts_reg.list$RC_ID <- droplevels(Nuts_reg.list$RC_ID)

```

```{r}
#| echo: false
#| eval: false

m_nuts_reg <- ulam(
    alist(
        Nuts_Found ~ dbinom( 3 , p ),
        logit(p) <- RegChr[RC_ID],
        RegChr[RC_ID] ~ dnorm(0,1.5)
    ), data=Nuts_reg.list , chains=4
    )

saveRDS(m_nuts_reg, "stan_models/m_nuts_reg.rds")


```

```{r}
#| echo: false
#| warning: false
#| message: false
#| output: false

m_nuts_reg <- readRDS("stan_models/m_nuts_reg.rds")

m_nuts_reg.df <- m_nuts_reg %>%
  spread_draws(RegChr[RC_ID])

m_nuts_reg.df %>% mutate(Region = case_when(
  RC_ID >= 9 &  RC_ID <=12 ~ "SI",
  RC_ID >= 1 & RC_ID <= 4 ~ "CI",
  RC_ID >= 5 & RC_ID <= 8  ~ "NI"
))  %>% mutate(Chrono = case_when(
    RC_ID == 4 |  RC_ID == 8 | RC_ID==12  ~ "R",
    RC_ID == 2 |  RC_ID == 6 | RC_ID == 10  ~ "LR",
    RC_ID == 1 |  RC_ID == 5 | RC_ID == 9  ~ "EMA",
    RC_ID == 3 |  RC_ID == 7 | RC_ID == 11 ~ "Ma"
)) -> m_nuts_reg.df

m_nuts_reg.plot <- ggplot(
  data = m_nuts_reg.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(RegChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_nuts_reg.df$RegChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(factor(Region, levels=c("SI", "CI", "NI")) ~ ., scales = "free") +
  labs(
    title = "Nuts",
    subtitle = "Macroregional distribution",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each macroregion and chronology.\nThe circle indicates the mean for each line."
  )

```

```{r}
#| echo: false
#| label: fig-bayes-glm-nuts-macroregion
#| fig-cap: "Bayesian probability estimates for nuts, divided by macroregion and chronology.\nThe prediction estimates are produced with a GLM and weakly informative priors. Credible intervals are provided."

m_nuts_reg.plot

```

#### Domestic and wild fruits

```{r}
#| echo: false

####################
## Domestic FRUITS 
####################

# Convert to list
DomFruit_reg.list <- list(
    DF_Found = DomFruit$Seed_Count,
    DF_Tot = 7,
    RC_ID = as.factor((interaction(DomFruit$Chronology, 
                                   DomFruit$Macroregion)))
   )

DomFruit_reg.list$RC_ID <- droplevels(DomFruit_reg.list$RC_ID)

```

```{r}
#| echo: false
#| eval: false

m_dfruit_reg <- ulam(
    alist(
        DF_Found ~ dbinom( 7 , p ),
        logit(p) <- RegChr[RC_ID],
        RegChr[RC_ID] ~ dnorm(0,1.5)
    ), data=DomFruit_reg.list , chains=4
    )

m_berries_reg <- ulam(
    alist(
        Berries_Found ~ dbinom( 9 , p ),
        logit(p) <- RegChr[RC_ID],
        RegChr[RC_ID] ~ dnorm(0,1.5)
    ), data=Berries_reg.list , chains=4
    )

saveRDS(m_dfruit_reg, "stan_models/m_dfruit_reg.rds")
saveRDS(m_berries_reg, "stan_models/m_berries_reg.rds")


```

```{r}
#| echo: false
#| warning: false
#| message: false
#| output: false

m_berries_reg <- readRDS("stan_models/m_berries_reg.rds")

m_berries_reg.df <- m_berries_reg %>%
  spread_draws(RegChr[RC_ID])

m_berries_reg.df %>% mutate(Region = case_when(
  RC_ID >= 9 &  RC_ID <=12 ~ "SI",
  RC_ID >= 1 & RC_ID <= 4 ~ "CI",
  RC_ID >= 5 & RC_ID <= 8  ~ "NI"
))  %>% mutate(Chrono = case_when(
  RC_ID == 4 |  RC_ID == 8 | RC_ID==12  ~ "R",
  RC_ID == 2 |  RC_ID == 6 | RC_ID == 10  ~ "LR",
  RC_ID == 1 |  RC_ID == 5 | RC_ID == 9  ~ "EMA",
  RC_ID == 3 |  RC_ID == 7 | RC_ID == 11 ~ "Ma"
)) -> m_berries_reg.df

m_berries_reg.plot <- ggplot(
  data = m_berries_reg.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(RegChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_berries_reg.df$RegChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(factor(Region, levels=c("SI", "CI", "NI")) ~ ., scales = "free") +
  labs(
    title = "Berries",
    subtitle = "Macroregional distribution",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each macroregion and chronology.\nThe circle indicates the mean for each line."
  )


m_dfruit_reg <- readRDS("stan_models/m_dfruit_reg.rds")

m_dfruit_reg.df <- m_dfruit_reg %>%
  spread_draws(RegChr[RC_ID])

m_dfruit_reg.df %>% mutate(Region = case_when(
  RC_ID >= 9 &  RC_ID <=12 ~ "SI",
  RC_ID >= 1 & RC_ID <= 4 ~ "CI",
  RC_ID >= 5 & RC_ID <= 8  ~ "NI"
))  %>% mutate(Chrono = case_when(
  RC_ID == 4 |  RC_ID == 8 | RC_ID==12  ~ "R",
  RC_ID == 2 |  RC_ID == 6 | RC_ID == 10  ~ "LR",
  RC_ID == 1 |  RC_ID == 5 | RC_ID == 9  ~ "EMA",
  RC_ID == 3 |  RC_ID == 7 | RC_ID == 11 ~ "Ma"
)) -> m_dfruit_reg.df

m_dfruit_reg.plot <- ggplot(
  data = m_dfruit_reg.df,
  aes(
    y = (factor(Chrono, levels = c("R", "LR", "EMA", "Ma"))),
    x = inv_logit(RegChr)
  )
) +
  stat_interval(
    .width = c(.50, .80, .95, .99),
    linewidth = 3
  ) +
    stat_summary(
    geom = "point",
    fun = "mean",
    col = "white",
    size = 2,
    shape = 1
  )+
  geom_vline(
    xintercept = inv_logit(mean(m_dfruit_reg.df$RegChr)),
    linetype = "twodash",
    linewidth = 0.45,
    color = "red4"
  ) +
  scale_color_brewer(palette = "Greys") +
  scale_y_discrete(limits = rev) +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  theme_tidybayes() +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +
  facet_grid(factor(Region, levels=c("SI", "CI", "NI")) ~ ., scales = "free") +
  labs(
    title = "Domestic Fruits",
    subtitle = "Macroregional distribution",
    x = "Probability",
    y = "Chronology",
    color = "Credible interval",
    caption = "The dashed line indicates the mean for each macroregion and chronology.\nThe circle indicates the mean for each line."
  )

```

```{r}
#| echo: false
#| label: fig-bayes-glm-domfruits-macroregion
#| fig-cap: "Bayesian probability estimates for domestic fruits, divided by macroregion and chronology.\nThe prediction estimates are produced with a GLM and weakly informative priors. Credible intervals are provided."

m_dfruit_reg.plot

```

```{r}
#| echo: false
#| label: fig-bayes-glm-berries-macroregion
#| fig-cap: "Bayesian probability estimates for domestic fruits, divided by macroregion and chronology.\nThe prediction estimates are produced with a GLM and weakly informative priors. Credible intervals are provided."

m_berries_reg.plot

```

## Altitude

The creation of altitude models was not possible for every plant investigated in this study. As the process is very time consuming, it was necessary to select only plants that are most likely to be either positively or negatively impacted by altitude, or taxa that are cultivated for economic reasons. Primary importance was thus given to cereals. Since not every cereal can be cultivated at high altitudes, it was more appropriate to model them individually instead of grouping them into noble and minor grains. For reference, below is a breakdown of the elevation of sites during the four chronologies under investigation.

The probability of occurrence of the most common cereal remains can be modelled against the elevation of sites in the four time periods under consideration. It is worth noting that the sites where the archaeobotanical remains have been found are not evenly distributed. In the Roman age, most sites investigated are located between 0 and 100 MSL, whereas after there is an increasing number of remains from sites between at higher elevations. Whether this reflects a real shift in settlement patterns is outside the aims of this study, but it might still be informative to visualise the different distribution of sites across elevations.

```{r}
#| echo: false

# Load dataset
bot_altitude <- read.csv("/Users/robertoragno/Desktop/University/Bari/PhD - Quarto/Database export/bot_altitude.csv", header=TRUE, sep=";")

# All elevations already > 0

# Convert to PA
bot_altitude[,c(14:ncol(bot_altitude))] <- decostand(bot_altitude[,c(14:ncol(bot_altitude))], method = "pa")
bot_altitude[is.na(bot_altitude)] <- 0

# Create a chronology table for the map
bot_altitude.chronotable <- table(factor(bot_altitude$Chronology, levels = chrono_levels))
```

```{r}
#| echo: false
#| fig-height: 8

bot_altitude %>% 
  ggplot(aes(x=site_altitude/1000)) +
  geom_histogram(bins=80, alpha=.6, aes(y = after_stat(ndensity)) )+ 
  geom_density(aes(y=after_stat(ndensity)), adjust=0.3, color = "red4", linewidth=0.75)+
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1,
                                        colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
    labs(
       y="Density",
       x="Altitude (km)",
       title="Sites distribution",
       caption="Density of sites scaled from 0 to 1."
       )+
  facet_grid(factor(Chronology, levels=chrono_levels)~.)



```

### Model specification and priors

$$
P_{i} \sim Bernoulli(\bar{p}_{i})
$$

$$
logit(\bar{p}_{i}) = \alpha_{[ChrID]} + \beta_{[ChrID]}\cdot Alt_{i}
$$

$$
\alpha_{ChrID} \sim Normal(0,1.5)
$$

$$
\beta_{ChrID} \sim Normal(0,1.5)
$$

$$
\phi \sim Exponential(1)
$$

```{r}
#| echo: false
#| label: fig-prior-pred-cereals-altitude
#| fig-cap: "Prior predictive simulation for the altitude models used in this section."

# Prior predictive simulation:
simplehist(rbern(1000, 
                  inv_logit(
                    rnorm(1e4, 0, 1.5)+rnorm(1e4, 0, 1.5)*sample(bot_altitude$site_altitude/1000, size=1e4, replace=T)
    )
                  ),
           xlab="Taxa", 
  main="Prior Predictive Simulation: Altitude",
           col=rangi2)
```

### Cereals

```{r}
#| echo: false
# Create grain lists

dat.CWheat_Altitude = list(
  N = 1, # 1 for Bernoulli trials
  A = bot_altitude$Common.Wheat, 
  Chr_id = as.numeric(as.factor(bot_altitude$Chronology)), 
  Alt = bot_altitude$site_altitude/1000,
  J = nrow(bot_altitude)
  )

dat.Barley_Altitude = list(
  N = 1, # 1 for Bernoulli trials
  A = bot_altitude$Barley, 
  Chr_id = as.numeric(as.factor(bot_altitude$Chronology)), 
  Alt = bot_altitude$site_altitude/1000,
  J = nrow(bot_altitude)
  )

dat.Einkorn_Altitude = list(
  N = 1, # 1 for Bernoulli trials
  A = bot_altitude$Einkorn, 
  Chr_id = as.numeric(as.factor(bot_altitude$Chronology)), 
  Alt = bot_altitude$site_altitude/1000,
  J = nrow(bot_altitude)
  )

dat.Emmer_Altitude = list(
  N = 1, # 1 for Bernoulli trials
  A = bot_altitude$Emmer, 
  Chr_id = as.numeric(as.factor(bot_altitude$Chronology)), 
  Alt = bot_altitude$site_altitude/1000,
  J = nrow(bot_altitude)
  )

dat.Rye_Altitude = list(
  N = 1, # 1 for Bernoulli trials
  A = bot_altitude$Rye, 
  Chr_id = as.numeric(as.factor(bot_altitude$Chronology)), 
  Alt = bot_altitude$site_altitude/1000,
  J = nrow(bot_altitude)
  )

dat.Millets_Altitude = list(
  N = 2, # 1 for binomial 
  A = bot_altitude$Proso.millet+bot_altitude$Foxtail.millet, 
  Chr_id = as.numeric(as.factor(bot_altitude$Chronology)), 
  Alt = bot_altitude$site_altitude/1000,
  J = nrow(bot_altitude)
  )

dat.Sorghum_Altitude = list(
  N = 2, # 1 for Bernoulli t. 
  A = bot_altitude$Sorghum, 
  Chr_id = as.numeric(as.factor(bot_altitude$Chronology)), 
  Alt = bot_altitude$site_altitude/1000,
  J = nrow(bot_altitude)
  )
```

```{r}
#| echo: false
#| eval: false

m_cwheat_alt <- ulam(
    alist(
        A ~ dbinom( 1 , p ),
        logit(p) <- a[Chr_id] + b[Chr_id]*(Alt),
        a[Chr_id] ~ dnorm(0,1.5),
        b[Chr_id] ~ dnorm(0,1.5)
    ), data=dat.CWheat_Altitude , chains=4
    )

m_barley_alt <- ulam(
    alist(
        A ~ dbinom( 1 , p ),
        logit(p) <- a[Chr_id] + b[Chr_id]*(Alt),
        a[Chr_id] ~ dnorm(0,1.5),
        b[Chr_id] ~ dnorm(0,1.5)
    ), data=dat.Barley_Altitude , chains=4
    )

m_emmer_alt <- ulam(
    alist(
        A ~ dbinom( 1 , p ),
        logit(p) <- a[Chr_id] + b[Chr_id]*(Alt),
        a[Chr_id] ~ dnorm(0,1.5),
        b[Chr_id] ~ dnorm(0,1.5)
    ), data=dat.Emmer_Altitude , chains=4
    )

m_einkorn_alt <- ulam(
    alist(
        A ~ dbinom( 1 , p ),
        logit(p) <- a[Chr_id] + b[Chr_id]*(Alt),
        a[Chr_id] ~ dnorm(0,1.5),
        b[Chr_id] ~ dnorm(0,1.5)
    ), data=dat.Einkorn_Altitude , chains=4
    )

m_Rye_alt <- ulam(
    alist(
        A ~ dbinom( 1 , p ),
        logit(p) <- a[Chr_id] + b[Chr_id]*(Alt),
        a[Chr_id] ~ dnorm(0,1.5),
        b[Chr_id] ~ dnorm(0,1.5)
    ), data=dat.Rye_Altitude , chains=4
    )

m_Millets_alt <- ulam(
    alist(
        A ~ dbinom( 2 , p ),
        logit(p) <- a[Chr_id] + b[Chr_id]*(Alt),
        a[Chr_id] ~ dnorm(0,1.5),
        b[Chr_id] ~ dnorm(0,1.5)
    ), data=dat.Millets_Altitude , chains=4
    )

m_Sorghum_alt <- ulam(
    alist(
        A ~ dbinom( 1 , p ),
        logit(p) <- a[Chr_id] + b[Chr_id]*(Alt),
        a[Chr_id] ~ dnorm(0,1.5),
        b[Chr_id] ~ dnorm(0,1.5)
    ), data=dat.Sorghum_Altitude , chains=4
    )

saveRDS(m_cwheat_alt, "stan_models/m_cwheat_alt.rds")
saveRDS(m_barley_alt, "stan_models/m_barley_alt.rds")
saveRDS(m_emmer_alt, "stan_models/m_emmer_alt.rds")
saveRDS(m_einkorn_alt, "stan_models/m_einkorn_alt.rds")
saveRDS(m_Rye_alt, "stan_models/m_Rye_alt.rds")
saveRDS(m_Millets_alt, "stan_models/m_Millets_alt.rds")
saveRDS(m_Sorghum_alt, "stan_models/m_Sorghum_alt.rds")


```

```{r}
#| echo: false
#| message: false
#| warning: false

library(modelr)

# Read models
m_cwheat_alt <- readRDS("stan_models/m_cwheat_alt.rds")
m_barley_alt <- readRDS("stan_models/m_barley_alt.rds")
m_emmer_alt <- readRDS("stan_models/m_emmer_alt.rds")
m_einkorn_alt <- readRDS("stan_models/m_einkorn_alt.rds")
m_Rye_alt <- readRDS("stan_models/m_Rye_alt.rds")
m_Millets_alt <- readRDS("stan_models/m_Millets_alt.rds")
m_Sorghum_alt <- readRDS("stan_models/m_Sorghum_alt.rds")

## PLOTS

# Common Wheat
m_cwheat_alt.post <- extract.samples(m_cwheat_alt)

m_cwheat_alt.plot <- as.data.frame(dat.CWheat_Altitude) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(Alt = seq_range(Alt, n = 101), Chronology) %>%
  add_linpred_draws(m_cwheat_alt) %>%
  ggplot(aes(x = Alt, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
    labs(
       y="P (Common Wheat | 1)",
       x="Altitude (km)",
       title="Common Wheat",
       subtitle="Altitude"
       )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))

# Barley
m_Barley_alt.post <- extract.samples(m_barley_alt)

m_Barley_alt.plot <- as.data.frame(dat.Barley_Altitude) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(Alt = seq_range(Alt, n = 101), Chronology) %>%
  add_linpred_draws(m_barley_alt) %>%
  ggplot(aes(x = Alt, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
  labs(
    y="P (Barley | 1)",
    x="Altitude (km)",
    title="Barley",
    subtitle="Altitude"
  )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))

# Emmer
m_Emmer_alt.post <- extract.samples(m_emmer_alt)

m_Emmer_alt.plot <- as.data.frame(dat.Emmer_Altitude) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(Alt = seq_range(Alt, n = 101), Chronology) %>%
  add_linpred_draws(m_emmer_alt) %>%
  ggplot(aes(x = Alt, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
  labs(
    y="P (Emmer | 1)",
    x="Altitude (km)",
    title="Emmer",
    subtitle="Altitude"
  )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))

# Einkorn
m_Einkorn_alt.post <- extract.samples(m_einkorn_alt)

m_Einkorn_alt.plot <- as.data.frame(dat.Einkorn_Altitude) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(Alt = seq_range(Alt, n = 101), Chronology) %>%
  add_linpred_draws(m_einkorn_alt) %>%
  ggplot(aes(x = Alt, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
  labs(
    y="P (Einkorn | 1)",
    x="Altitude (km)",
    title="Einkorn",
    subtitle="Altitude"
  )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))

# Rye

m_Rye_alt.post <- extract.samples(m_Rye_alt)

m_Rye_alt.plot <- as.data.frame(dat.Rye_Altitude) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(Alt = seq_range(Alt, n = 101), Chronology) %>%
  add_linpred_draws(m_Rye_alt) %>%
  ggplot(aes(x = Alt, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
  labs(
    y="P (Rye | 1)",
    x="Altitude (km)",
    title="Rye",
    subtitle="Altitude"
  )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))

# Millets

m_Millets_alt.post <- extract.samples(m_Millets_alt)

m_Millets_alt.plot <- as.data.frame(dat.Millets_Altitude) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(Alt = seq_range(Alt, n = 101), Chronology) %>%
  add_linpred_draws(m_Millets_alt) %>%
  ggplot(aes(x = Alt, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
  labs(
    y="P (Millets | 2)",
    x="Altitude (km)",
    title="Millets",
    subtitle="Altitude"
  )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))

# Sorghum
m_Sorghum_alt.post <- extract.samples(m_Sorghum_alt)

m_Sorghum_alt.plot <- as.data.frame(dat.Sorghum_Altitude) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(Alt = seq_range(Alt, n = 101), Chronology) %>%
  add_linpred_draws(m_Sorghum_alt) %>%
  ggplot(aes(x = Alt, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
  labs(
    y="P (Sorghum | 1)",
    x="Altitude (km)",
    title="Sorghum",
    subtitle="Altitude"
  )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))


```

```{r}
#| echo: false

m_cwheat_alt.plot
m_Barley_alt.plot
m_Emmer_alt.plot
m_Einkorn_alt.plot
m_Rye_alt.plot
m_Millets_alt.plot
m_Sorghum_alt.plot

```

#### Community plot

```{r}
#| echo: false


m_cwheat_alt.a <- as.data.frame(m_cwheat_alt.post) %>% mutate(Plant = "Common_Wheat")
m_Barley_alt.a <- as.data.frame(m_Barley_alt.post) %>% mutate(Plant = "Barley")
m_Emmer_alt.a <- as.data.frame(m_Emmer_alt.post) %>% mutate(Plant = "Emmer")
m_Einkorn_alt.a <- as.data.frame(m_Einkorn_alt.post) %>% mutate(Plant = "Einkorn")
m_Rye_alt.a <- as.data.frame(m_Rye_alt.post) %>% mutate(Plant = "Rye")
m_Millets_alt.a <- as.data.frame(m_Millets_alt.post) %>% mutate(Plant = "Millets")
m_Sorghum_alt.a <- as.data.frame(m_Sorghum_alt.post) %>% mutate(Plant = "Sorghum")

Cerals_Alt_binded <- bind_rows(
  m_cwheat_alt.a,
  m_Barley_alt.a,
  m_Emmer_alt.a,
  m_Einkorn_alt.a,
  m_Rye_alt.a,
  m_Millets_alt.a,
  m_Sorghum_alt.a
)

names(Cerals_Alt_binded)[1:8] <- c("a.EMA", "a.LR", "a.Ma", "a.R", "b.EMA", "b.LR", "b.Ma", "b.R")

# Reshape
Cereals_Alt_R <- Cerals_Alt_binded %>%
  select(Plant, a= a.R, b= b.R) %>%
  mutate(Chronology = "R")

Cereals_Alt_LR <- Cerals_Alt_binded %>%
  select(Plant, a=a.LR, b=b.LR) %>%
  mutate(Chronology = "LR")

Cereals_Alt_EMA <- Cerals_Alt_binded %>%
  select(Plant, a=a.EMA, b=b.EMA) %>%
  mutate(Chronology = "EMA")

Cereals_Alt_Ma <- Cerals_Alt_binded %>%
  select(Plant, a=a.Ma, b=b.Ma) %>%
  mutate(Chronology = "Ma")

Cereals_Alt_post <- bind_rows(Cereals_Alt_R, Cereals_Alt_LR, Cereals_Alt_EMA, Cereals_Alt_Ma)

# end reshape

Cereals_Alt_post.plot <- ggplot(Cereals_Alt_post, aes(x = inv_logit(a), y = b, color = Plant)) +
  geom_point(alpha = .3) +
  theme_tidybayes() +
  scale_color_brewer(palette = "Accent") +
  theme(
    legend.position = "bottom",
    strip.background = element_rect(
      fill = "grey",
      linewidth = 0.1,
      colour = "black"
    ),
    panel.background = element_rect(fill = "grey90"),
    panel.border = element_rect(fill = NA, linewidth = 0.1),
    panel.grid.major.x = element_line(
      color = "grey50",
      linewidth = 0.25,
      linetype = 2
    ),
    axis.title.x.top = element_blank()
  ) +  
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  scale_x_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  scale_y_continuous(
    breaks = scales::pretty_breaks(n = 10),
    sec.axis = dup_axis()
  ) +
  labs(
    x = "Intercept",
    y = "Slope",
    color = "Cereal",
    title = "Model estimates: logit(p) = Intercept+Slope*Altitude",
    subtitle = "Altitude"
  )+
  facet_grid(factor(Chronology, levels=chrono_levels)~., scales="free")

```

```{r}
#| echo: false
#| fig-height: 10
#| label: fig-cereals-alt
#| fig-cap: "MCMC estimates for slope and intercept plotted in the logit scale. Negative slopes indicate a negative relationship between the plant occurrence and increasing altitude. Intercepts were kept as a baseline occurrence probability of the taxa. Taxa on the left of the graph are rarer, while taxa on the right are more common. It is important to notice that this graph represents the taxa response to elevation." 

Cereals_Alt_post.plot
```

### Legumes

```{r}
#| echo: false

####################
## LEGUMES 
####################

# Convert to list
dat.Legumes_Altitude = list(
  N = 7, # Tot number of legumes taxa
  A = rowSums(bot_altitude[24:30]), 
  Chr_id = as.numeric(as.factor(bot_altitude$Chronology)), 
  Alt = bot_altitude$site_altitude/1000,
  J = nrow(bot_altitude)
  )

```

```{r}
#| echo: false
#| eval: false

m_Legumes_altitude <- ulam(
    alist(
        A ~ dbinom( 7 , p ),
        logit(p) <- a[Chr_id] + bAlt[Chr_id]*(Alt),
        a[Chr_id] ~ dnorm(0,1.5),
        bAlt[Chr_id] ~ dnorm(0,1.5)
    ), data=dat.Legumes_Altitude , chains=4, log_lik=T
    )

saveRDS(m_Legumes_altitude, "stan_models/m_Legumes_altitude.rds")

```

```{r}
#| echo: false
m_Legumes_altitude <- readRDS("stan_models/m_Legumes_altitude.rds")

m_Legumes_altitude.post <- extract.samples(m_Legumes_altitude)

m_Legumes_altitude.plot <- as.data.frame(dat.Legumes_Altitude) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(Alt = seq_range(Alt, n = 101), Chronology) %>%
  add_linpred_draws(m_Legumes_altitude) %>%
  ggplot(aes(x = Alt, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
  labs(
    y="P (Legumes | 1)",
    x="Altitude (km)",
    title="Legumes",
    subtitle="Altitude"
  )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))

```

```{r}
#| echo: false

m_Legumes_altitude.plot

```

### Fruits

```{r}
#| echo: false

# Create grain lists

dat.Grape_Altitude = list(
  N = 1, # 1 for Bernoulli trials
  A = bot_altitude$Grape, 
  Chr_id = as.numeric(as.factor(bot_altitude$Chronology)), 
  Alt = bot_altitude$site_altitude/1000,
  J = nrow(bot_altitude)
  )

```

```{r}
#| echo: false
#| eval: false

m_grape_altitude <- ulam(
    alist(
        A ~ dbinom( 1 , p ),
        logit(p) <- a[Chr_id] + bAlt[Chr_id]*(Alt),
        a[Chr_id] ~ dnorm(0,1.5),
        bAlt[Chr_id] ~ dnorm(0,1.5)
    ), data=dat.Grape_Altitude , chains=4, log_lik=T
    )

saveRDS(m_grape_altitude, "stan_models/m_grape_altitude.rds")

```

```{r}
#| echo: false

# Read models
m_grape_altitude <- readRDS("stan_models/m_grape_altitude.rds")

# Plots

# Common Wheat
m_Grape_alt.post <- extract.samples(m_grape_altitude)

m_Grape_alt.plot <- as.data.frame(dat.Grape_Altitude) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(Alt = seq_range(Alt, n = 101), Chronology) %>%
  add_linpred_draws(m_grape_altitude) %>%
  ggplot(aes(x = Alt, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
  labs(
    y="P (Grape | 1)",
    x="Altitude (km)",
    title="Grape",
    subtitle="Altitude"
  )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))

```

#### Grape

```{r}
#| echo: false

m_Grape_alt.plot

```

#### Olives

```{r}
#| echo: false

# Careful - this model is stored in this file after, under the "Temperature" section. If I need to recreate it, run the code below first.

dat.Olive_altitude = list(
  N = 1, # 1 for Bernoulli trials
  A = bot_altitude$Olive, 
  Chr_id = as.numeric(as.factor(bot_altitude$Chronology)), 
  Alt = bot_altitude$site_altitude / 1000, 
  J = nrow(bot_altitude)
  )

m_Olive_altitude <- readRDS("stan_models/precipitation_models/m_Olive_altitude.rds")

m_Olive_altitude.post <- extract.samples(m_Olive_altitude)

m_Olive_altitude.plot <- as.data.frame(dat.Olive_altitude) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(Alt = seq_range(Alt, n = 101), Chronology) %>%
  add_linpred_draws(m_Olive_altitude) %>%
  ggplot(aes(x = Alt, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
  labs(
    y="P (Olive | 1)",
    x="Altitude (km)",
    title="Olive",
    subtitle="Altitude"
  )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))

```

```{r}
#| echo: false

m_Olive_altitude.plot
```

## Model comparisons

### Precipitation

#### Model specification and priors

##### Model 1: Precipitation only

The following model uses standardized mean annual precipitation values as a coefficient for the slope and weakly informative priors for both the intercept and the slope.

$$
P_{i} \sim Bernoulli(\bar{p}_{i})
$$

$$
logit(\bar{p}_{i}) = \alpha_{[ChrID]} + bPrecip_{[ChrID]}\cdot MeanAnnualPrecip
$$

$$
\alpha_{ChrID} \sim Normal(0,1.3)
$$

$$
bPrecip_{ChrID} \sim Normal(0,1.3)
$$

##### Model 2: Altitude only

The following model uses altitude values (in km) as a coefficient for the slope and weakly informative priors for both the intercept and the slope. It is the same model presented before.

$$
P_{i} \sim Bernoulli(\bar{p}_{i})
$$

$$
logit(\bar{p}_{i}) = \alpha_{[ChrID]} + bAlt_{[ChrID]}\cdot Altitude
$$

$$
\alpha_{ChrID} \sim Normal(0,1.3)
$$

$$
bAlt_{ChrID} \sim Normal(0,1.3)
$$

##### Model 3: Altitude and Precipitation

The following model uses altitude (in km) and standardized mean annual precipitation values as coefficients for the slope, and weakly informative priors for both the intercept and the slope.

$$
P_{i} \sim Bernoulli(\bar{p}_{i})
$$

$$
logit(\bar{p}_{i}) = \alpha_{[ChrID]} + bAlt_{[ChrID]}\cdot Altitude + bPrecip_{[ChrID]}\cdot MeanAnnualPrecip
$$

$$
\alpha_{ChrID} \sim Normal(0,1.3)
$$

$$
bAlt_{ChrID} \sim Normal(0,1.3)
$$

$$
bPrecip_{ChrID} \sim Normal(0,1.3)
$$

```{r}
#| echo: false
#| eval: true
#| message: false

library(raster)

prec_raster_list <- list()

for(i in 1:12){
  file_name <- paste0("/Users/robertoragno/Desktop/University/Bari/PhD - Quarto/Rasters/wc2_precip/wc2.1_2.5m_prec_", sprintf("%02d", i), ".tif")
  prec_raster_list[[i]] <- raster(file_name)
}

# assign each raster file to a variable with a meaningful name
names <- paste0("prec_", sprintf("%02d", 1:12))
for(i in 1:12){
  assign(names[i], prec_raster_list[[i]])
}

precipStack = raster::stack(prec_raster_list)

bot_altitude.Coord <- bot_altitude
  
coordinates(bot_altitude.Coord)= ~ x+y

precip_rasValue=extract(precipStack, bot_altitude.Coord)
precip_rasValue_Mean = data.frame(Precip_Mean = rowMeans(precip_rasValue))

bot_altitude_precip=cbind(bot_altitude.Coord,precip_rasValue_Mean)

bot_altitude_precip$Precip_Mean <- standardize(bot_altitude_precip$Precip_Mean) 

# Create a list

dat.CWheat_Precip = list(
  N = 1, # 1 for Bernoulli trials
  A = bot_altitude_precip$Common.Wheat, 
  Chr_id = as.numeric(as.factor(bot_altitude_precip$Chronology)), 
  Alt = bot_altitude_precip$site_altitude / 1000, 
  MeanPrec = bot_altitude_precip$Precip_Mean,
  J = nrow(bot_altitude_precip)
  )

```

##### Prior predictive simulations

We also want to make sure that the priors are weakly informative and are not deeply impacting the models.

```{r}
#| echo: false
#| label: fig-prior-pred-cereals-precip
#| fig-cap: "Prior predictive simulation for the precipitation models used in this section."
#| fig-subcap: 
#|  - "Single coefficient"
#|  - "Two coefficients"
#| layout-ncol: 2

# Prior predictive simulation:

simplehist(rbern(1000, 
                  inv_logit(
                    rnorm(1e4, 0, 1.3)+
                    rnorm(1e4, 0,1.3)*sample(bot_altitude_precip$Precip_Mean, size=1e4, replace=T)
    )
                  ),
           xlab="Taxa", 
  main="Prior Predictive Simulation: One coefficient",
           col=rangi2)

simplehist(rbern(1000, 
                 inv_logit(
                    rnorm(1e4, 0, 1.3) + 
    rnorm(1e4, 0, 1.3)*sample(bot_altitude_precip$Precip_Mean, 
                              size=1e4, replace=T)+
    rnorm(1e4, 0, 1.3)*sample(bot_altitude_precip$site_altitude/1000, 
                              size=1e4, replace=T)
    )
                  ),
           xlab="Taxa", 
 main="Prior Predictive Simulation: Two coefficients",
           col=rangi2)

```

#### Performance and comparisons

```{r}
#| echo: false
#| eval: false

m_Cwheat_precip <- ulam(
    alist(
        A ~ dbinom( 1 , p ),
        logit(p) <- a[Chr_id] + bPrec[Chr_id]*MeanPrec,
        a[Chr_id] ~ dnorm(0,1.3),
        bPrec[Chr_id] ~ dnorm(0,1.3)
    ), data=dat.CWheat_Precip , chains=4, log_lik = T
    )

m_CWheat_precip_alt <- ulam(
    alist(
        A ~ dbinom( 1 , p ),
        logit(p) <- a[Chr_id] + bPrec[Chr_id]*MeanPrec + bAlt[Chr_id]*(Alt),
        a[Chr_id] ~ dnorm(0,1.3),
        bPrec[Chr_id] ~ dnorm(0,1.3),
        bAlt[Chr_id] ~ dnorm(0,1.3)
    ), data=dat.CWheat_Precip , chains=4, log_lik=T
    )

m_CWheat_altitude <- ulam(
    alist(
        A ~ dbinom( 1 , p ),
        logit(p) <- a[Chr_id] + bAlt[Chr_id]*(Alt),
        a[Chr_id] ~ dnorm(0,1.5),
        bAlt[Chr_id] ~ dnorm(0,1.5)
    ), data=dat.CWheat_Precip , chains=4,  log_lik=T
    )

# Save RDS 
saveRDS(m_Cwheat_precip, "stan_models/precipitation_models/m_Cwheat_precip.rds")
saveRDS(m_CWheat_altitude, "stan_models/precipitation_models/m_Cwheat_altitude.rds")
saveRDS(m_CWheat_precip_alt, "stan_models/precipitation_models/m_CWheat_precip_alt.rds")

```

The comparison of the three models using the WAIC measure does not show a significant difference between the three models. Although for simplicity only the common wheat models are shown, repeated calculation for several other plants (including non cereal plants) did not show a significant impact of adding mean annual precipitation to the model.

```{r}
#| echo: false
m_Cwheat_precip <- readRDS("stan_models/precipitation_models/m_Cwheat_precip.rds")
m_CWheat_altitude <- readRDS("stan_models/precipitation_models/m_CWheat_altitude.rds")
m_CWheat_precip_alt <- readRDS("stan_models/precipitation_models/m_Cwheat_precip_alt.rds")

compare(m_Cwheat_precip, m_CWheat_altitude, m_CWheat_precip_alt, func = "WAIC")
```

```{r}
# Test prior
m_Cwheat_precip
```

```{r}
#| echo: false
#| label: fig-coef-prec-alt-wheat-models
#| fig-cap: "Slope coefficients for the three models under examination. The [numbers] indicate the chronological levels."
#| fig-subcap: 
#|  - "Precipitation coefficients"
#|  - "Altitude coefficients"
#| layout-ncol: 2

plot( coeftab(m_Cwheat_precip,m_CWheat_altitude, m_CWheat_precip_alt), par=5:8)
plot( coeftab(m_Cwheat_precip,m_CWheat_altitude, m_CWheat_precip_alt), par=c(243:246) )

```

```{r}
#| echo: false
#| eval: false

## PLOTS

# Common Wheat
m_cwheat_precip.post <- extract.samples(m_cwheat_precip)

m_cwheat_precip.plot <- as.data.frame(dat.CWheat_Precip) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(MeanPrec = seq_range(MeanPrec, n = 51), Chronology) %>%
  add_linpred_draws(m_cwheat_precip) %>%
  ggplot(aes(x = MeanPrec, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
    labs(
       y="P (Common Wheat | 1)",
       x="Scaled Mean Annual Precipitation",
       title="Common Wheat",
       subtitle="Precipitation"
       )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))


# Barley
m_Barley_precip.post <- extract.samples(m_barley_precip)

m_Barley_precip.plot <- as.data.frame(dat.Barley_Precip) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(MeanPrec = seq_range(MeanPrec, n = 51), Chronology) %>%
  add_linpred_draws(m_barley_precip) %>%
  ggplot(aes(x = MeanPrec, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
  labs(
    y="P (Barley | 1)",
    x="Scaled Mean Annual Precipitation",
    title="Barley",
    subtitle="Precipitation"
  )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))

# Rye
m_Rye_precip.post <- extract.samples(m_Rye_precip)

m_Rye_precip.plot <- as.data.frame(dat.Rye_Precip) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(MeanPrec = seq_range(MeanPrec, n = 51), Chronology) %>%
  add_linpred_draws(m_Rye_precip) %>%
  ggplot(aes(x = MeanPrec, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
  labs(
    y="P (Rye | 1)",
    x="Scaled Mean Annual Precipitation",
    title="Rye",
    subtitle="Precipitation"
  )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))


```

## Temperature

```{r}
#| echo: false
temperature_raster_list <- list()

for(i in 1:12){
  file_name <- paste0("/Users/robertoragno/Desktop/University/Bari/PhD - Quarto/Rasters/wc2_temperature/wc2.1_2.5m_tavg_", sprintf("%02d", i), ".tif")
  temperature_raster_list[[i]] <- raster(file_name)
}

# assign each raster file to a variable with a meaningful name
names <- paste0("temperature_", sprintf("%02d", 1:12))
for(i in 1:12){
  assign(names[i], temperature_raster_list[[i]])
}

temperatureStack = raster::stack(temperature_raster_list)

temperature_rasValue=raster::extract(temperatureStack, bot_altitude.Coord)
temperature_rasValue_Mean = data.frame(temperature_Mean = rowMeans(temperature_rasValue))

bot_altitude_temperature=cbind(bot_altitude.Coord,temperature_rasValue_Mean)

bot_altitude_temperature$temperature_Mean <- standardize(bot_altitude_temperature$temperature_Mean) 

# Create a list

dat.CWheat_temperature = list(
  N = 1, # 1 for Bernoulli trials
  A = bot_altitude_temperature$Common.Wheat, 
  Chr_id = as.numeric(as.factor(bot_altitude_temperature$Chronology)), 
  Alt = bot_altitude_temperature$site_altitude / 1000, 
  MeanTemp = bot_altitude_temperature$temperature_Mean,
  J = nrow(bot_altitude_temperature)
  )

dat.Rye_temperature = list(
  N = 1, # 1 for Bernoulli trials
  A = bot_altitude_temperature$Rye, 
  Chr_id = as.numeric(as.factor(bot_altitude_temperature$Chronology)), 
  Alt = bot_altitude_temperature$site_altitude / 1000, 
  MeanTemp = bot_altitude_temperature$temperature_Mean,
  J = nrow(bot_altitude_temperature)
  )

legumes_altitude_temperature <- as.data.frame(bot_altitude_temperature)

dat.Legumes_temperature = list(
  N = 7, 
  A = rowSums(legumes_altitude_temperature[22:28]), 
  Chr_id = as.numeric(as.factor(legumes_altitude_temperature$Chronology)), 
  Alt = legumes_altitude_temperature$site_altitude / 1000, 
  MeanTemp = legumes_altitude_temperature$temperature_Mean,
  J = nrow(legumes_altitude_temperature)
  )

dat.Olive_temperature = list(
  N = 1, # 1 for Bernoulli trials
  A = bot_altitude_temperature$Olive, 
  Chr_id = as.numeric(as.factor(bot_altitude_temperature$Chronology)), 
  Alt = bot_altitude_temperature$site_altitude / 1000, 
  MeanTemp = bot_altitude_temperature$temperature_Mean,
  J = nrow(bot_altitude_temperature)
  )

dat.Grape_temperature = list(
  N = 1, # 1 for Bernoulli trials
  A = bot_altitude_temperature$Grape, 
  Chr_id = as.numeric(as.factor(bot_altitude_temperature$Chronology)), 
  Alt = bot_altitude_temperature$site_altitude / 1000, 
  MeanTemp = bot_altitude_temperature$temperature_Mean,
  J = nrow(bot_altitude_temperature)
  )

```


#### Model 1: Temperature only

The following model uses mean annual temperature values as a coefficient for the slope and weakly informative priors for both the intercept and the slope.

$$
P_{i} \sim Bernoulli(\bar{p}_{i})
$$

$$
logit(\bar{p}_{i}) = \alpha_{[ChrID]} + bTemp_{[ChrID]}\cdot MeanAnnualTemp
$$

$$
\alpha_{ChrID} \sim Normal(0,1.3)
$$

$$
bTemp_{ChrID} \sim Normal(0,1.3)
$$

$$
\phi \sim Exponential(1)
$$

#### Model 2: Altitude only

The following model uses altitude values (in km) as a coefficient for the slope and weakly informative priors for both the intercept and the slope. It is the same model presented before.

$$
P_{i} \sim Bernoulli(\bar{p}_{i})
$$

$$
logit(\bar{p}_{i}) = \alpha_{[ChrID]} + bAlt_{[ChrID]}\cdot Altitude
$$

$$
\alpha_{ChrID} \sim Normal(0,1.3)
$$

$$
bAlt_{ChrID} \sim Normal(0,1.3)
$$

$$
\phi \sim Exponential(1)
$$

#### Model 3: Altitude and Temperature

The following model uses altitude (in km) and standardized mean annual temperature values as coefficients for the slope, and weakly informative priors for both the intercept and the slope.

$$
P_{i} \sim Bernoulli(\bar{p}_{i})
$$

$$
logit(\bar{p}_{i}) = \alpha_{[ChrID]} + bAlt_{[ChrID]}\cdot Altitude + bTemp_{[ChrID]}\cdot MeanAnnualTemp
$$

$$
\alpha_{ChrID} \sim Normal(0,1.3)
$$

$$
bAlt_{ChrID} \sim Normal(0,1.3)
$$

$$
bTemp_{ChrID} \sim Normal(0,1.3)
$$

$$
\phi \sim Exponential(1)
$$

#### Prior predictive simulations

We also want to make sure that the priors are weakly informative and are not deeply impacting the models.

```{r}
#| echo: false
#| label: fig-prior-pred-cereals-temperature
#| fig-cap: "Prior predictive simulation for the temperature models used in this section."
#| fig-subcap: 
#|  - "Single coefficient"
#|  - "Two coefficients"
#| layout-ncol: 2

# Prior predictive simulation:

simplehist(rbern(1000, 
                  inv_logit(
                    rnorm(1e4, 0, 1.3)+
                    rnorm(1e4, 0,1.3)*sample(bot_altitude_precip$Precip_Mean, size=1e4, replace=T)
    )
                  ),
           xlab="Taxa", 
  main="Prior Predictive Simulation: One coefficient",
           col=rangi2)

simplehist(rbern(1000, 
                 inv_logit(
                    rnorm(1e4, 0, 1.3) + 
    rnorm(1e4, 0, 1.3)*sample(bot_altitude_precip$Precip_Mean, 
                              size=1e4, replace=T)+
    rnorm(1e4, 0, 1.3)*sample(bot_altitude_precip$site_altitude/1000, 
                              size=1e4, replace=T)
    )
                  ),
           xlab="Taxa", 
 main="Prior Predictive Simulation: Two coefficients",
           col=rangi2)


```

### Performance and comparisons

The creation of models for each plant is extremely time consuming, and for the purposes of this comparison I chose to compare only taxa that are known to be more sensitive to temperature and that have economic implications.

#### Common wheat

The comparison of the three models using the WAIC, although showing a slightly larger distance as opposed to the precipitation models, is still not significant enough to justify the introduction of another predictor in the model.

```{r}
#| echo: false
#| eval: false

m_Cwheat_temperature <- ulam(
  alist(
    A ~ dbinom( 1 , p ),
    logit(p) <- a[Chr_id] + bTemp[Chr_id]*MeanTemp,
    a[Chr_id] ~ dnorm(0,1.3),
    bTemp[Chr_id] ~ dnorm(0,1.3)
  ), data=dat.CWheat_temperature , chains=4, log_lik = T
)

m_CWheat_temperature_alt <- ulam(
  alist(
    A ~ dbinom( 1 , p ),
    logit(p) <- a[Chr_id] + bTemp[Chr_id]*MeanTemp + bAlt[Chr_id]*(Alt),
    a[Chr_id] ~ dnorm(0,1.3),
    bTemp[Chr_id] ~ dnorm(0,1.3),
    bAlt[Chr_id] ~ dnorm(0,1.3)
  ), data=dat.CWheat_temperature , chains=4, log_lik=T
)

# Save RDS 
saveRDS(m_Cwheat_temperature, "stan_models/precipitation_models/m_Cwheat_temperature.rds")
saveRDS(m_CWheat_temperature_alt, "stan_models/precipitation_models/m_CWheat_temperature_alt.rds")
```

```{r}
#| echo: false
m_Cwheat_temperature <- readRDS("stan_models/precipitation_models/m_Cwheat_temperature.rds")
m_CWheat_temperature_alt <- readRDS("stan_models/precipitation_models/m_CWheat_temperature_alt.rds")

compare(m_Cwheat_temperature, m_CWheat_altitude, m_CWheat_temperature_alt, func = "WAIC")
```

```{r}
#| echo: false
#| label: fig-coef-temp-alt-wheat-models
#| fig-cap: "Slope coefficients for the three models under examination. The [numbers] indicate the chronological levels."
#| fig-subcap: 
#|  - "Temperature coefficients"
#|  - "Altitude coefficients"
#| layout-ncol: 2

plot( coeftab(m_Cwheat_temperature,m_CWheat_altitude, m_CWheat_temperature_alt), par=5:8)
plot( coeftab(m_Cwheat_temperature,m_CWheat_altitude, m_CWheat_temperature_alt), par=c(243:246) )

```

#### Rye

The comparison of the three models using the WAIC is not significant enough to justify the introduction of another predictor in the model.

```{r}
#| echo: false
#| eval: false
m_Rye_temperature <- ulam(
  alist(
    A ~ dbinom( 1 , p ),
    logit(p) <- a[Chr_id] + bTemp[Chr_id]*MeanTemp,
    a[Chr_id] ~ dnorm(0,1.3),
    bTemp[Chr_id] ~ dnorm(0,1.3)
  ), data=dat.Rye_temperature , chains=4, log_lik = T
)

m_Rye_temperature_alt <- ulam(
  alist(
    A ~ dbinom( 1 , p ),
    logit(p) <- a[Chr_id] + bTemp[Chr_id]*MeanTemp + bAlt[Chr_id]*(Alt),
    a[Chr_id] ~ dnorm(0,1.3),
    bTemp[Chr_id] ~ dnorm(0,1.3),
    bAlt[Chr_id] ~ dnorm(0,1.3)
  ), data=dat.Rye_temperature , chains=4, log_lik=T
)

m_Rye_altitude <- ulam(
  alist(
    A ~ dbinom( 1 , p ),
    logit(p) <- a[Chr_id] + bAlt[Chr_id]*(Alt),
    a[Chr_id] ~ dnorm(0,1.3),
    bAlt[Chr_id] ~ dnorm(0,1.3)
  ), data=dat.Rye_temperature , chains=4, log_lik=T
)

# Save RDS 
saveRDS(m_Rye_temperature, "stan_models/precipitation_models/m_Rye_temperature.rds")
saveRDS(m_Rye_temperature_alt, "stan_models/precipitation_models/m_Rye_temperature_alt.rds")
saveRDS(m_Rye_altitude, "stan_models/precipitation_models/m_Rye_altitude.rds")

```

```{r}
#| echo: false
m_Rye_temperature <- readRDS("stan_models/precipitation_models/m_Rye_temperature.rds")
m_Rye_temperature_alt <- readRDS("stan_models/precipitation_models/m_Rye_temperature_alt.rds")
m_Rye_altitude <- readRDS("stan_models/precipitation_models/m_Rye_altitude.rds")

compare(m_Rye_temperature, m_Rye_altitude, m_Rye_temperature_alt, func = "WAIC")
```

```{r}
#| echo: false
#| label: fig-coef-temp-alt-Rye-models
#| fig-cap: "Slope coefficients for the three models under examination. The [numbers] indicate the chronological levels."
#| fig-subcap: 
#|  - "Temperature coefficients"
#|  - "Altitude coefficients"
#| layout-ncol: 2

plot( coeftab(m_Rye_temperature,m_Rye_altitude, m_Rye_temperature_alt), par=5:8)
plot( coeftab(m_Rye_temperature,m_Rye_altitude, m_Rye_temperature_alt), par=c(243:246) )

```

#### Legumes

The comparison of the three models using the WAIC is not significant enough to justify the introduction of another predictor in the model.

```{r}
#| echo: false
#| eval: false
m_Legumes_temperature <- ulam(
  alist(
    A ~ dbinom( 7 , p ),
    logit(p) <- a[Chr_id] + bTemp[Chr_id]*MeanTemp,
    a[Chr_id] ~ dnorm(0,1.3),
    bTemp[Chr_id] ~ dnorm(0,1.3)
  ), data=dat.Legumes_temperature , chains=4, log_lik = T
)

m_Legumes_temperature_alt <- ulam(
  alist(
    A ~ dbinom( 7 , p ),
    logit(p) <- a[Chr_id] + bTemp[Chr_id]*MeanTemp + bAlt[Chr_id]*(Alt),
    a[Chr_id] ~ dnorm(0,1.3),
    bTemp[Chr_id] ~ dnorm(0,1.3),
    bAlt[Chr_id] ~ dnorm(0,1.3)
  ), data=dat.Legumes_temperature , chains=4, log_lik=T
)

# Save RDS
saveRDS(m_Legumes_temperature, "stan_models/precipitation_models/m_Legumes_temperature.rds")
saveRDS(m_Legumes_temperature_alt, "stan_models/precipitation_models/m_Legumes_temperature_alt.rds")

```

```{r}
#| echo: false
m_Legumes_temperature <- readRDS("stan_models/precipitation_models/m_Legumes_temperature.rds")
m_Legumes_temperature_alt <- readRDS("stan_models/precipitation_models/m_Legumes_temperature_alt.rds")

compare(m_Legumes_temperature, m_Legumes_altitude, m_Legumes_temperature_alt, func = "WAIC")

```

```{r}
#| echo: false
#| label: fig-coef-temp-alt-Legumes-models
#| fig-cap: "Slope coefficients for the three models under examination. The [numbers] indicate the chronological levels."
#| fig-subcap: 
#|  - "Temperature coefficients"
#|  - "Altitude coefficients"
#| layout-ncol: 2

plot( coeftab(m_Legumes_temperature,m_Legumes_altitude, m_Legumes_temperature_alt), par=5:8)
plot( coeftab(m_Legumes_temperature,m_Legumes_altitude, m_Legumes_temperature_alt), par=c(243:246) )

```

#### Grape

The combination of temperature and altitude as predictors for grape occurrence did not produce any strong enough difference that would favour the use of a predictor in place of the other.

```{r}
#| echo: false
#| eval: false
m_Grape_temperature <- ulam(
  alist(
    A ~ dbinom( 1 , p ),
    logit(p) <- a[Chr_id] + bTemp[Chr_id]*MeanTemp,
    a[Chr_id] ~ dnorm(0,1.3),
    bTemp[Chr_id] ~ dnorm(0,1.3)
  ), data=dat.Grape_temperature , chains=4, log_lik = T
)

m_Grape_temperature_alt <- ulam(
  alist(
    A ~ dbinom( 1 , p ),
    logit(p) <- a[Chr_id] + bTemp[Chr_id]*MeanTemp + bAlt[Chr_id]*(Alt),
    a[Chr_id] ~ dnorm(0,1.3),
    bTemp[Chr_id] ~ dnorm(0,1.3),
    bAlt[Chr_id] ~ dnorm(0,1.3)
  ), data=dat.Grape_temperature , chains=4, log_lik=T
)

# Save RDS
saveRDS(m_Grape_temperature, "stan_models/precipitation_models/m_Grape_temperature.rds")
saveRDS(m_Grape_temperature_alt, "stan_models/precipitation_models/m_Grape_temperature_alt.rds")

```

```{r}
#| echo: false
m_Grape_temperature <- readRDS("stan_models/precipitation_models/m_Grape_temperature.rds")
m_Grape_temperature_alt <- readRDS("stan_models/precipitation_models/m_Grape_temperature_alt.rds")

compare(m_Grape_temperature, m_grape_altitude, m_Grape_temperature_alt, func = "WAIC")

```

```{r}
#| echo: false
#| label: fig-coef-temp-alt-Grape-models
#| fig-cap: "Slope coefficients for the three models under examination. The [numbers] indicate the chronological levels."
#| fig-subcap: 
#|  - "Temperature coefficients"
#|  - "Altitude coefficients"
#| layout-ncol: 2

plot( coeftab(m_Grape_temperature,m_grape_altitude, m_Grape_temperature_alt), par=5:8)
plot( coeftab(m_Grape_temperature,m_grape_altitude, m_Grape_temperature_alt), par=c(243:246) )

```

#### Olive

If the model is applied to other types of plants, the situation changes. In the case of olives the prediction accuracy increases when the mean annual temperature and the altitudes are both slope coefficients.

```{r}
#| echo: false
#| eval: false
m_Olive_temperature <- ulam(
  alist(
    A ~ dbinom( 1 , p ),
    logit(p) <- a[Chr_id] + bTemp[Chr_id]*MeanTemp,
    a[Chr_id] ~ dnorm(0,1.3),
    bTemp[Chr_id] ~ dnorm(0,1.3)
  ), data=dat.Olive_temperature , chains=4, log_lik = T
)

m_Olive_temperature_alt <- ulam(
  alist(
    A ~ dbinom( 1 , p ),
    logit(p) <- a[Chr_id] + bTemp[Chr_id]*MeanTemp + bAlt[Chr_id]*(Alt),
    a[Chr_id] ~ dnorm(0,1.3),
    bTemp[Chr_id] ~ dnorm(0,1.3),
    bAlt[Chr_id] ~ dnorm(0,1.3)
  ), data=dat.Olive_temperature , chains=4, log_lik=T
)

m_Olive_altitude <- ulam(
  alist(
    A ~ dbinom( 1 , p ),
    logit(p) <- a[Chr_id] + bAlt[Chr_id]*(Alt),
    a[Chr_id] ~ dnorm(0,1.3),
    bAlt[Chr_id] ~ dnorm(0,1.3)
  ), data=dat.Olive_temperature , chains=4, log_lik=T
)

# Save RDS 
saveRDS(m_Olive_temperature, "stan_models/precipitation_models/m_Olive_temperature.rds")
saveRDS(m_Olive_temperature_alt, "stan_models/precipitation_models/m_Olive_temperature_alt.rds")
saveRDS(m_Olive_altitude, "stan_models/precipitation_models/m_Olive_altitude.rds")

```

```{r}
#| echo: false
m_Olive_temperature <- readRDS("stan_models/precipitation_models/m_Olive_temperature.rds")
m_Olive_temperature_alt <- readRDS("stan_models/precipitation_models/m_Olive_temperature_alt.rds")
m_Olive_altitude <- readRDS("stan_models/precipitation_models/m_Olive_altitude.rds")

compare(m_Olive_temperature, m_Olive_altitude, m_Olive_temperature_alt, func = "WAIC")
```

```{r}
#| echo: false
#| label: fig-coef-temp-alt-olive-models
#| fig-cap: "Slope coefficients for the three models under examination. The [numbers] indicate the chronological levels."
#| fig-subcap: 
#|  - "Temperature coefficients"
#|  - "Altitude coefficients"
#| layout-ncol: 2

plot( coeftab(m_Olive_temperature,m_Olive_altitude, m_Olive_temperature_alt), par=5:8)
plot( coeftab(m_Olive_temperature,m_Olive_altitude, m_Olive_temperature_alt), par=c(243:246) )

```

Given that the model which used temperature and altitude performed better than the individual slope models, it is worth it to look at the predicted olive occurrence probability plotted against:

-   the standardised mean annual temperatures.

-   elevation (km).

The chronological differences seem to be consistent until the 11th century. Sites with higher temperatures have a higher likelihood of consuming/producing olives. Likewise, sites with higher altitudes have a reduced probability of consuming or producing the same plant.

```{r}
#| echo: false

# Olive
m_Olive_temperature.post <- extract.samples(m_Olive_temperature)

m_Olive_temperature.plot <- as.data.frame(dat.Olive_temperature) %>%
  group_by(Chr_id) %>%
  mutate(Chronology = case_when(
    Chr_id == 1 ~ "EMA",
    Chr_id == 2 ~ "LR",
    Chr_id == 3 ~ "Ma",
    Chr_id == 4 ~ "R"
  )) %>% 
  data_grid(MeanTemp = seq_range(MeanTemp, n = 101), Chronology) %>%
  add_linpred_draws(m_Olive_temperature) %>%
  ggplot(aes(x = MeanTemp, y = .linpred)) +
  stat_lineribbon(aes(y = .linpred), color="grey90") +
  scale_fill_brewer(palette = "Greys")+ 
  theme_tidybayes()+
  theme(legend.position = "bottom", 
        strip.background = element_rect(fill = "grey",
                                        linewidth = 0.1, colour="black"),
        panel.background = element_rect(fill = "grey90"),
        panel.border = element_rect(fill=NA, linewidth = 0.1),
        panel.grid.major.x = element_line(color = "grey50",
                                          linewidth = 0.25,
                                          linetype = 2),
        axis.title.x.top = element_blank()
  )+
  labs(
    y="P (Olive | 1)",
    x="Mean Annual Temperature (std)",
    title="Olive",
    subtitle="Temperature"
  )+
  facet_wrap(~ factor(Chronology, levels=chrono_levels))


```

```{r}
#| echo: false
#| label: fig-m-olive-temp-alt-plot
#| fig-cap: "Temperature and elevation models for olive occurrence."
#| fig-subcap: 
#|  - "Olive occurrence prediction plotted against standardised temperatures. The mean annual location temperatures ranged between 4-16°C (mean from January to December for each site)."
#|  - "Olive occurrence prediction plotted against altitude."
#| layout-nrow: 2

m_Olive_temperature.plot
m_Olive_altitude.plot
```


## Cereal proportions
The computations on the archaeobotanical dataset that have been done so far are based on presence/absence values. The reasons relate to the numerous biases present in the samples, which skew the distributions. However, this approach does not allow to draw any quantitative conclusion. From a qualitative standpoint, it can be informative to see which sites are producing different results by calculating the ratio of single cereal taxa on the total of cereal grains found in a certain sample. For the sake of exploring the quantitative trends, keeping in mind that these results are heavily biased by outliers and sample sizes, summary tables grouped by chronology were produced. In particular, two tables are presented here. The first (@tbl-Cereals-Ratios-Means) takes into account missing values, so that if a particular taxon was not found in a sample the missing value was converted to 0. The second table (@tbl-Cereals-Ratios-Means-Pres-Only) calculates the means only based on true presences, and missing values are ignored from the computation. In addition to these two tables, a different approach has also been presented. Raw data has been converted into relative ranks, which assigns increasing ranks to the count values (excluding zeros) on a scale of 0 to 1, thus minimizing the impact of extreme outliers and reducing the effects of large differences in values. @tbl-Cereals-Ranks-ratios-means displays the means of the relative ranks, grouped by chronology. In all three approaches, the computations have been based only on totals of cereals attributed to a species. Although these tables allow some considerations on the proportions of cereals in the sites under investigation, it is important to remember that the results might be biased by the quality of the samples.  

```{r}
#| echo: false

###################
## CEREAL RATIOS ##
###################

# Calculate the ratio of each cereal on the total of cereals by site
# Just for qualitative purposes

Cereals_Ratios = Archaeobot_Condensed
Cereals_Ratios[is.na(Cereals_Ratios)] = 0

# Only select sites with cereals
Cereals_Ratios = subset(Cereals_Ratios, Tot..Cereals>0)

# Only select cereal columns
Cereals_Ratios = Cereals_Ratios[,1:24]

# Get TOT without Unsp..
Cereals_Ratios$Tot_Grains = Cereals_Ratios$Tot..Cereals - Cereals_Ratios$Unsp..cereals

# Remove Unsp..Cereals
Cereals_Ratios = Cereals_Ratios[,-23]

# Remove rows that only have Unsp..Cereals (that are now NAs)
Cereals_Ratios = Cereals_Ratios[rowSums(Cereals_Ratios[,14:22], na.rm = T) > 0, ]

# Calculate ratios
Cereals_Ratios[,14:22] =  Cereals_Ratios[,14:22] / Cereals_Ratios$Tot_Grains
Cereals_Ratios[,14:22] = round(Cereals_Ratios[,14:22],2)

# Remove the Tot..Cereals column
Cereals_Ratios = Cereals_Ratios[,-23]

#########################
## CEREAL RATIOS MEANS ##
#########################

# Just for explorative purposes, group by Chronology

# Get the number of observations/chronology to attach to the dataframe
Cereals_Obs_Chrono_Counts = Cereals_Ratios %>% 
  group_by(factor(Chronology, levels=(c("R", "LR", "EMA", "Ma")))) %>%
  summarise(Tot_Samples=n())

# Get the sample size to attach to the dataframe
Cereals_Obs_Chrono_Size = Cereals_Ratios %>% 
  group_by(factor(Chronology, levels=(c("R", "LR", "EMA", "Ma")))) %>%
  summarise(Sample_Size=sum(Tot_Grains))
Cereals_Obs_Chrono_Size$Sample_Size = round(Cereals_Obs_Chrono_Size$Sample_Size)

# This mean includes the 0 values
Cereals_Ratios_Means = Cereals_Ratios %>% 
  group_by(factor(Chronology, levels=(c("R", "LR", "EMA", "Ma")))) %>%
  summarise_at(vars(Common.Wheat:Sorghum), mean) %>%
  ungroup()

Cereals_Ratios_Means[,-1] = round(Cereals_Ratios_Means[,-1],2)

Cereals_Ratios_Means = cbind(Cereals_Ratios_Means, 
                             Sample_Size = Cereals_Obs_Chrono_Size$Sample_Size,
                             Tot_Samples=Cereals_Obs_Chrono_Counts$Tot_Samples)
colnames(Cereals_Ratios_Means)[1] = "Chronology"

# This mean does not include the 0 values
Cereals_Ratios_Pres_Only = Cereals_Ratios
Cereals_Ratios_Pres_Only[Cereals_Ratios_Pres_Only==0] = NA

Cereals_Ratios_Means_Pres_Only = Cereals_Ratios_Pres_Only %>% 
  group_by(factor(Chronology, levels=(c("R", "LR", "EMA", "Ma")))) %>%
  summarise_at(vars(Common.Wheat:Sorghum), mean, na.rm = TRUE) %>%
  ungroup()

Cereals_Ratios_Means_Pres_Only[,-1] = round(Cereals_Ratios_Means_Pres_Only[,-1],2)

colnames(Cereals_Ratios_Means_Pres_Only)[1] = "Chronology"
Cereals_Ratios_Means_Pres_Only = cbind(Cereals_Ratios_Means_Pres_Only, 
                                       Sample_Size = Cereals_Obs_Chrono_Size$Sample_Size,
                                       Tot_Samples=Cereals_Obs_Chrono_Counts$Tot_Samples)

## Relative ranks

Cereals_Ranks_ratios = Archaeobot_Condensed
#Cereals_Ranks_ratios[is.na(Cereals_Ranks_ratios)] = 0

# Only select sites with cereals
Cereals_Ranks_ratios = subset(Cereals_Ranks_ratios, Tot..Cereals>0)

# Only select cereal columns, without Unsp.. Cereals
Cereals_Ranks_ratios = Cereals_Ranks_ratios[,1:24]
Cereals_Ranks_ratios = Cereals_Ranks_ratios[,-23]

# Remove rows that only have Unsp..Cereals (that are now NAs)
Cereals_Ranks_ratios = Cereals_Ranks_ratios[rowSums(Cereals_Ranks_ratios[,14:22], na.rm = T) > 0, ]

# Get the number of observations/chronology to attach to the dataframe
Cereals_Obs_Chrono_Counts_Ranks = Cereals_Ranks_ratios %>% 
  group_by(factor(Chronology, levels=(c("R", "LR", "EMA", "Ma")))) %>%
  summarise(Tot_Samples=n())

# Calculate relative ranks
Cereals_Ranks_ratios[,14:22] = decostand(Cereals_Ranks_ratios[,14:22], 
                                         method = "rrank", 
                                         na.rm = T)

Cereals_Ranks_ratios_means = Cereals_Ranks_ratios %>% 
  group_by(factor(Chronology, levels=(c("R", "LR", "EMA", "Ma")))) %>%
  summarise_at(vars(Common.Wheat:Sorghum), mean, na.rm = TRUE) %>%
  ungroup()

Cereals_Ranks_ratios_means[,-1] = round(Cereals_Ranks_ratios_means[,-1],2)

colnames(Cereals_Ranks_ratios_means)[1] = "Chronology"
Cereals_Ranks_ratios_means = cbind(Cereals_Ranks_ratios_means, 
                                   Sample_Size = Cereals_Obs_Chrono_Size$Sample_Size,
                                   Tot_Samples=Cereals_Obs_Chrono_Counts_Ranks$Tot_Samples)

```

::: {.content-visible when-format="html"}

```{r}
#| echo: false
#| message: false
#| label: tbl-Cereals-Ratios-Means
#| tbl-cap: "Means of the proportions of cereals, calculated on the total of cereals. The means have been calculated including missing values. Results grouped by chronology."

library(knitr)
library(kableExtra)

kable(t(Cereals_Ratios_Means)) %>%
  kable_styling() %>% 
  row_spec(11, bold = T, extra_css = "border-top: 1px solid") %>% 
  row_spec(12, bold = T) %>% 
  row_spec(1, bold = T, extra_css = "border-bottom: 1px solid") 


```

```{r}
#| echo: false
#| label: tbl-Cereals-Ratios-Means-Pres-Only
#| tbl-cap: "Means of the proportions of cereals, calculated on the total of cereals. The means have been calculated only on true presences, excluding missing values. Results grouped by chronology."

kable(t(Cereals_Ratios_Means_Pres_Only)) %>%
  kable_styling() %>% 
  row_spec(11, bold = T, extra_css = "border-top: 1px solid") %>% 
  row_spec(12, bold = T) %>% 
  row_spec(1, bold = T, extra_css = "border-bottom: 1px solid") 

```

```{r}
#| echo: false
#| label: tbl-Cereals-Ranks-ratios-means
#| tbl-cap: "Relative ranks means, grouped by chronology. The ranks have been calculated only on cereals attributed to a species (excluding the category of unspecified cereals)."

Cereals_Ranks_ratios_means=t(Cereals_Ranks_ratios_means)

kable(Cereals_Ranks_ratios_means) %>%
  kable_styling() %>% 
  row_spec(11, bold = T, extra_css = "border-top: 1px solid") %>% 
  row_spec(12, bold = T) %>% 
  row_spec(1, bold = T, extra_css = "border-bottom: 1px solid") 


```
:::

## To do:

### Wine/Olive oil production in Italy

Questions: Is there a decrease in the production of cash crops in Late Roman villas? In particular in central Italian villas.

Available data:

-   Seed remains

-   Wine presses in Roman Italy (1st to 6th c. ca) -\> Dodd

-   Wine/Olive presses, dated but no info on wine/olive or size: http://oxrep.classics.ox.ac.uk/databases/olive_oil_and_wine_presses_database/

-   Dodd: "a notable increase in size from around the first century BCE." No quantitative data provided.

### Fruit consumption

-   The domesticated and the wild

-   What fruits arrive on the Roman table?

-   Can we see a decreased consumption of figs during the LALIA in the north?

## Test: Gaussian processes

```{r}
#| eval: false
#| echo: false

# 1. Load the dataset
Bot_Sites_for_GPR <- Archaeobot_Condensed

# 2. See which Chronology has more data
table(Bot_Sites_for_GPR$Chronology)
# It is the Roman. 

# 3. Let's check for imbalances in macroregions
table((subset(Bot_Sites_for_GPR, Chronology=="EMA"))$Macroregion)
Bot_Sites_for_GPR<-subset(Bot_Sites_for_GPR, Chronology=="EMA" & Macroregion=="Northern Italy")
# Central Italy has only 5 sites. N and S are kind of balanced
# Decide later whether to remove C Italy

library(geosphere)

# I want an index so I know which sites are which
Bot_Sites_for_GPR$Incremental_Index = 1:nrow(Bot_Sites_for_GPR)

Bot_Sites_for_GPR_Coords <- data.frame(X= Bot_Sites_for_GPR$X, Y= Bot_Sites_for_GPR$Y, row.names = Bot_Sites_for_GPR$Incremental_Index)

Bot_Sites_for_GPR_DistMatrix <- distm(Bot_Sites_for_GPR_Coords, fun = distHaversine)/1000
Bot_Sites_for_GPR_DistMatrix <- round(Bot_Sites_for_GPR_DistMatrix,1)

rownames(Bot_Sites_for_GPR_DistMatrix) <- Bot_Sites_for_GPR$Site
colnames(Bot_Sites_for_GPR_DistMatrix) <- Bot_Sites_for_GPR$Site
head(Bot_Sites_for_GPR_DistMatrix)

# Ok distance matrix is ready
# Now let's decide a covariation curve
curve( exp(-1*x) , from=0 , to=4 , lty=2 )
curve( exp(-1*x^2) , add=TRUE )

names(Bot_Sites_for_GPR)

Bot_Sites_for_GPR.EMA_MG <- subset(Minor_Grains, Chronology=="EMA" & Macroregion=="Northern Italy")
Bot_Sites_for_GPR.EMA_MG$ID <- Bot_Sites_for_GPR$ID
Bot_Sites_for_GPR.EMA_MG$Observation <- 1:nrow(Bot_Sites_for_GPR.EMA_MG)

dat.Bot_Sites_for_GPR.EMA_MG <- list(
    MG_Found = Bot_Sites_for_GPR.EMA_MG$Grain_Count, 
    Tot_MG_Grains = Bot_Sites_for_GPR.EMA_MG$All_Grain_Count,
    Observation=Bot_Sites_for_GPR.EMA_MG$Observation,
    Dmat=Bot_Sites_for_GPR_DistMatrix)
        
        
m14.8 <- ulam(
    alist(
        MG_Found ~ dbinom(7, p),
        logit(p) <- Intercept * exp(Site[Observation]),
        vector[42]:Site ~ multi_normal( 0 , SIGMA ),
        matrix[42,42]:SIGMA <- cov_GPL2( Dmat , 
                                         etasq , 
                                         rhosq , 
                                         0.01 ),
        Intercept ~ dexp(1),
        etasq ~ dexp( 2 ),
        rhosq ~ dexp( 0.5 )
    ), data=dat.Bot_Sites_for_GPR.EMA_MG , chains=4 , cores=4 , iter=2000 )

m14.8nc <- ulam(
    alist(
        MG_Found ~ dbinom(7, p),
        logit(p) <- a*exp(Site[Observation]),
        # non-centered Gaussian Process prior
        transpars> vector[42]: Site <<- L_SIGMA * z,
        vector[42]: z ~ normal( 0 , 1 ),
        transpars> matrix[42,42]: L_SIGMA <<- cholesky_decompose( SIGMA ),
        transpars> matrix[42,42]: SIGMA <- cov_GPL2( Dmat , 
                                                     etasq , rhosq , 0.01 ),
        a ~ dexp( 1 ),
        etasq ~ dexp( 2 ),
        rhosq ~ dexp( 0.5 )
 ), data=dat.Bot_Sites_for_GPR.EMA_MG , chains=4 , cores=4 , iter=2000 )


```
